<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Language Design Team</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item "><a href="initiatives.html"><strong aria-hidden="true">2.</strong> Initiatives</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="initiatives/priorities.html"><strong aria-hidden="true">2.1.</strong> Current priorities</a></li><li class="chapter-item "><a href="initiatives/stable.html"><strong aria-hidden="true">2.2.</strong> Stabilized initiatives</a></li><li class="chapter-item "><a href="initiatives/process.html"><strong aria-hidden="true">2.3.</strong> Process</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="initiatives/process/roles.html"><strong aria-hidden="true">2.3.1.</strong> Roles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="initiatives/process/roles/owner.html"><strong aria-hidden="true">2.3.1.1.</strong> Owner</a></li><li class="chapter-item "><a href="initiatives/process/roles/liaison.html"><strong aria-hidden="true">2.3.1.2.</strong> Liaison</a></li></ol></li><li class="chapter-item "><a href="initiatives/process/stages.html"><strong aria-hidden="true">2.3.2.</strong> Stages</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="initiatives/process/stages/proposal.html"><strong aria-hidden="true">2.3.2.1.</strong> Proposal</a></li><li class="chapter-item "><a href="initiatives/process/stages/experimental.html"><strong aria-hidden="true">2.3.2.2.</strong> Experimental</a></li><li class="chapter-item "><a href="initiatives/process/stages/development.html"><strong aria-hidden="true">2.3.2.3.</strong> Development</a></li><li class="chapter-item "><a href="initiatives/process/stages/feature_complete.html"><strong aria-hidden="true">2.3.2.4.</strong> Feature complete</a></li><li class="chapter-item "><a href="initiatives/process/stages/stabilized.html"><strong aria-hidden="true">2.3.2.5.</strong> Stabilized</a></li><li class="chapter-item "><a href="initiatives/process/stages/inactive.html"><strong aria-hidden="true">2.3.2.6.</strong> Inactive</a></li></ol></li><li class="chapter-item "><a href="initiatives/process/checklists.html"><strong aria-hidden="true">2.3.3.</strong> Checklists</a></li></ol></li><li class="chapter-item "><a href="initiatives/faq.html"><strong aria-hidden="true">2.4.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="decision_process.html"><strong aria-hidden="true">3.</strong> Decision process and principles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decision_process/examples.html"><strong aria-hidden="true">3.1.</strong> Decision process examples</a></li><li class="chapter-item "><a href="decision_process/reference.html"><strong aria-hidden="true">3.2.</strong> Decision process reference</a></li></ol></li><li class="chapter-item "><a href="how_to.html"><strong aria-hidden="true">4.</strong> Lang team "how to" guide</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how_to/nominate.html"><strong aria-hidden="true">4.1.</strong> Nominate an issue</a></li><li class="chapter-item "><a href="how_to/propose.html"><strong aria-hidden="true">4.2.</strong> Propose an initiative</a></li><li class="chapter-item "><a href="how_to/design_meeting.html"><strong aria-hidden="true">4.3.</strong> Request a design meeting</a></li></ol></li><li class="chapter-item "><a href="chat_platform.html"><strong aria-hidden="true">5.</strong> Chat platform</a></li><li class="chapter-item "><a href="calendar.html"><strong aria-hidden="true">6.</strong> Calendar</a></li><li class="chapter-item "><a href="meetings.html"><strong aria-hidden="true">7.</strong> Meetings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="meetings/triage.html"><strong aria-hidden="true">7.1.</strong> Triage meeting</a></li><li class="chapter-item "><a href="meetings/design.html"><strong aria-hidden="true">7.2.</strong> Planning and design meetings</a></li><li class="chapter-item "><a href="meetings/backlog-bonanza.html"><strong aria-hidden="true">7.3.</strong> Backlog bonanza</a></li></ol></li><li class="chapter-item "><a href="design_notes.html"><strong aria-hidden="true">8.</strong> Design notes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design_notes/int_literal_as_float.html"><strong aria-hidden="true">8.1.</strong> Allowing integer literals like 1 to be inferred to floating point</a></li><li class="chapter-item "><a href="design_notes/general_coroutines.html"><strong aria-hidden="true">8.2.</strong> Generalizing coroutines</a></li><li class="chapter-item "><a href="design_notes/fn_type_trait_impls.html"><strong aria-hidden="true">8.3.</strong> Extending the capabilities of compiler-generated function types</a></li><li class="chapter-item "><a href="design_notes/auto_traits.html"><strong aria-hidden="true">8.4.</strong> Auto traits</a></li><li class="chapter-item "><a href="design_notes/eager_drop.html"><strong aria-hidden="true">8.5.</strong> Eager drop</a></li><li class="chapter-item "><a href="design_notes/autoref_ops.html"><strong aria-hidden="true">8.6.</strong> Autoderef and autoref in operators</a></li><li class="chapter-item "><a href="design_notes/copy_ergonomics.html"><strong aria-hidden="true">8.7.</strong> Copy type ergonomics</a></li></ol></li><li class="chapter-item "><a href="roadmaps.html"><strong aria-hidden="true">9.</strong> Roadmaps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="roadmaps/roadmap-2024.html"><strong aria-hidden="true">9.1.</strong> Roadmap 2024</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Language Design Team</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the repository for the Rust Language Design Team.  This
page stores our administrative information, meeting minutes, as well
as some amount of design constraints. It's always a
work-in-progress (insert omnipresent mid 90s logo for under
construction here).</p>
<p>Key links:</p>
<ul>
<li><a href="https://github.com/orgs/rust-lang/projects/16/">Active initiatives project board</a>
<ul>
<li>Shows you the things that are currently under development (or exploration) within Rust.</li>
<li>You can <a href="./initiatives.html">read more about initiatives here</a>.</li>
</ul>
</li>
<li><a href="./calendar.html">Meeting calendar</a>, <a href="https://github.com/rust-lang/lang-team/tree/master/minutes">triage meeting minutes</a>, <a href="https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes">design meeting minutes</a>
<ul>
<li>You can <a href="./meetings.html">read more about our meetings here.</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiatives"><a class="header" href="#initiatives">Initiatives</a></h1>
<p>A lang team <strong>initiative</strong> is some active effort with a clear goal or deliverable.
Typically initiatives are changes to the language, but they could also be documentation, specifications, or something internal to the lang team.</p>
<h2 id="active-initiatives"><a class="header" href="#active-initiatives"><a href="https://github.com/orgs/rust-lang/projects/16/">Active initiatives</a></a></h2>
<p>Active initiatives are initiatives that have been assigned a lang-team <a href="./initiatives/process/roles/owner.html">Liaison</a> and which are actively underway. A complete list can be found in <a href="https://github.com/orgs/rust-lang/projects/16/">this GitHub project board</a>. Note that this list doesn't represent all unstable features; older features in particular were added without active initiatives.</p>
<p>Each initiative on the project board is linked to a tracking issue and has a status:</p>
<ul>
<li>The <a href="./initiatives/process/roles/owner.html">Owner</a> and <a href="./initiatives/process/roles/owner.html">Liaison</a> are assigned to the issue.</li>
<li>If the initiative has a dedicated repository, the issue is created on that repository (some initiatives don't require their own repos; they are found on rust-lang/rust or rust-lang/lang-team).</li>
<li>The <a href="./initiatives/process/stages.html">Stage</a> of the initiative:
<ul>
<li><a href="./initiatives/process/stages/experimental.html">Experimental</a> -- Drafting RFC; implementation work may begin on nightly as well</li>
<li><a href="./initiatives/process/stages/development.html">Development</a> -- Approved RFC; implementation is in progress on nightly</li>
<li><a href="./initiatives/process/stages/feature_complete.html">Feature complete</a> -- Implementation is complete on nightly and ready for widespread testing</li>
<li><a href="./initiatives/process/stages/stabilized.html">Stabilized</a> -- Implementation is complete and available on stable
<ul>
<li>To be stabilized, there must be a pending PR adding the feature to the Rust reference, but this PR may not yet have landed.</li>
<li>Other forms of integration, such as rustfmt, often take place after stabilization as well.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="proposed-initiatives"><a class="header" href="#proposed-initiatives">Proposed initiatives</a></h2>
<p>You can see the <a href="https://github.com/rust-lang/lang-team/issues?q=is%3Aissue+is%3Aopen+label%3Amajor-change">currently proposed initiatives</a> on Github. We review this list during <a href="./meetings.html">triage meetings</a> and decide whether to assign a liaison or close the proposal. If initiatives haven't received a liaison after 6 weeks of activity, we take that as a sign that there is no enthusiasm to pursue this and close the issue, but you are welcome to re-open the issue if you believe someone would be willing to liaison.</p>
<h2 id="how-does-one-propose-a-new-initiative"><a class="header" href="#how-does-one-propose-a-new-initiative">How does one propose a new initiative?</a></h2>
<p>It's easy! You just open a short issue describing your idea. Read more in the <a href="./initiatives/process.html">process</a> page!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="priorities"><a class="header" href="#priorities">Priorities</a></h1>
<p>This page describes the current lang team priorities and explains
their motivations. This page is typically updated as part of the
yearly Rust roadmap process. They are derived from a combination of
the Rust survey results, feedback from users, and other soruces. When
new project proposals are created, they can cite priorities listed in
this page.</p>
<p>Each priority also lists lang-team members who typically prefer to
liaison for issues in this area. This can give you an idea of who you
might reach out to if you wish to discuss a project proposal.</p>
<p><strong>Last updated:</strong> 2020-07-28</p>
<ul>
<li>Async I/O
<ul>
<li><strong>What?</strong> Continued improvements with ergonomics and productivity related to Async I/O.</li>
<li><strong>Why?</strong> Shows up heavily on the survey, this is an obvious area where a lot of Rust developers are working.</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a>, <a href="https://github.com/withoutboats">withoutboats</a>, <a href="https://github.com/cramertj">cramertj</a></li>
</ul>
</li>
<li>C Parity, interop, and embedded -- these often overlap in 'low level capabilities'
<ul>
<li><strong>What</strong>? Extending Rust's low-level capabilities to do &quot;things otherwise only possible in C or assembly&quot;, as well as enabling smooth, ergonomic FFI between other languages and Rust.</li>
<li><strong>Why?</strong> Embedded is a large factor in the survey.</li>
<li><strong>Why?</strong> Our ability to act like &quot;native C&quot; is a differentiating capability for Rust. We've seen a lot of traction integrating into big companies on this basis, as a C++ replacement. It's clear that doing this requires the ability to do piecewise adoption.</li>
<li><strong>Who:</strong> <a href="https://github.com/joshtriplett">joshtriplett</a></li>
</ul>
</li>
<li>Const generics and constant evaluation
<ul>
<li><strong>What?</strong> Supporting </li>
<li><strong>Why?</strong> Heavily requested feature and important for key areas.</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a>, <a href="https://github.com/withoutboats">withoutboats</a></li>
</ul>
</li>
<li>Trait and type system extensions
<ul>
<li><strong>What?</strong> Specifically impl Trait, GATs, and specialization</li>
<li><strong>Why?</strong> Long-standing areas that affect a lot of domains, including async</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a></li>
</ul>
</li>
<li>Error handling
<ul>
<li><strong>What?</strong> Combination of <a href="https://blog.yoshuawuyts.com/error-handling-survey/#conclusion">library related improvements</a> that consolidate &quot;best practices&quot; into standard library, documentation to describe how it works, as well as possible language improvements to leverage those changes (try blocks, <code>yeet</code>/<code>throw</code> keyword, etc).</li>
<li><strong>Why?</strong> Cross-cutting productivity concern, and a persistent problem that makes working with Rust code more difficult than it should be.</li>
<li><strong>Why?</strong> Anecdotally, something that comes up for a lot of people (see e.g. <a href="https://www.ncameron.org/blog/rust-in-2020-one-more-thing/">nrc's #rust2020 blog post</a>)</li>
<li><strong>Who:</strong> <a href="https://github.com/withoutboats">withoutboats</a>, <a href="https://github.com/joshtriplett">joshtriplett</a></li>
</ul>
</li>
<li>Borrow checker expressiveness and other lifetime issues
<ul>
<li><strong>What?</strong> Think Polonius, RFC 2229, RFC 66, and other ideas like knowing which fields of <code>self</code> are used by particular methods.</li>
<li><strong>Why?</strong> Learning curve remains a stubborn problem, and the best way to improve it is to make the compiler smarter.</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a>, <a href="https://github.com/pnkfelix">pnkfelix</a></li>
</ul>
</li>
<li>Unsafe code capabilities and reference material
<ul>
<li><strong>What?</strong> Document the rules for legal unsafe code and add features that either add required capabilities or make correct code easier and more ergonomic to write.</li>
<li><strong>Why?</strong> Growing base of unsafe code, changes here are getting harder, this represents a kind of &quot;reputation risk&quot;. We really want to be &quot;better than C&quot; here.</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a>, <a href="https://github.com/pnkfelix">pnkfelix</a></li>
</ul>
</li>
<li>Targeted ergonomic wins and extensions
<ul>
<li><strong>What?</strong> Small additions or improvements to make Rust easier to use.</li>
<li><strong>Why?</strong> These will never rise to the &quot;top of the list&quot;, but they often have outsized impact on people's enjoyment of Rust.</li>
<li><strong>Who:</strong> <a href="https://github.com/scottmcm">scottmcm</a></li>
</ul>
</li>
<li>Soundness holes to try and correct
<ul>
<li><strong>What?</strong> </li>
<li><strong>Why?</strong> Rust's appeal rests on safety. We have to make steady progress on these points. It's often hard to prioritize them compared to &quot;whiz-bang&quot; features. Also, long-running safety issues can cause fallout when fixed, weakening our stability guarantees.</li>
<li><strong>Who:</strong> <a href="https://github.com/nikomatsakis">nikomatsakis</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stabilized-initiatives"><a class="header" href="#stabilized-initiatives">Stabilized initiatives</a></h1>
<p>This table lists past initiatives which were stabilized.</p>
<div class="table-wrapper"><table><thead><tr><th>Initiative</th><th></th><th><a href="initiatives/./process/stages.html">Stage</a></th><th><a href="initiatives/./process/roles/owner.html">Owner</a></th><th><a href="initiatives/./process/roles/liaison.html">Liaison</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/rust-lang/project-rfc-2229/">Disjoint closure capture</a></td><td>✅</td><td><a href="initiatives/./process/stages/stabilized.html">▰▰▰▰▰</a></td><td>nikomatsakis</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="process"><a class="header" href="#process">Process</a></h1>
<p>This page describes how lang team initiatives work. This is the process to use if you have an idea for a change you would like to make in the language.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In a nutshell, the process for a successful initiative is as follows:</p>
<ul>
<li>Have an idea
<ul>
<li>Talk about it on internals, Zulip, etc to flesh it out a bit</li>
<li>Ideally, identify a potential <a href="initiatives/./process/roles/owner.html">owner</a></li>
</ul>
</li>
<li>Open a <a href="initiatives/./process/stages/proposal.html">proposal</a> as an issue on the lang-team repository
<ul>
<li>A lang team member can decide to be your <a href="initiatives/./process/roles/liaison.html">liaison</a> and <a href="initiatives/./process/stages/proposal.html#exit-seconding-a-proposal"><em>second</em> your proposal</a>.</li>
<li>Once that happens, we will create a Zulip stream, tracking issue, and (optionally) repository, etc.</li>
</ul>
</li>
<li>If warranted, <a href="initiatives/./process/stages/experimental.html">explore</a> the design space and author the RFC
<ul>
<li>In this phase, the <a href="initiatives/./process/roles/owner.html">owner</a> works with the <a href="initiatives/./process/roles/liaison.html">liaison</a> and other contributors to expore the design space and develop the RFC</li>
<li>Code can be landed in this phase, but the feature gate is marked as &quot;experimental&quot; and its associated page in the <a href="https://doc.rust-lang.org/nightly/unstable-book/the-unstable-book.html">Unstable Book</a> also incudes a disclaimer that the content has not been RFC'd.</li>
<li>Users of the feature gate will get a warning that the RFC is under development</li>
<li>Once the RFC is ready, it can be opened on the RFC repository and approved by the lang team</li>
</ul>
</li>
<li>Finish <a href="initiatives/./process/stages/development.html">development</a>
<ul>
<li>At this point, development proceeds but the feature gate does not have to be marked as &quot;experimental&quot; (the unstable book can also be updated).</li>
<li>The goal here is both to implement the feature and to create an &quot;explainer&quot; that guides people on what it does (this can be located in the unstable book or elsewhere).</li>
</ul>
</li>
<li><a href="initiatives/./process/stages/feature_complete.html">Feature complete</a>
<ul>
<li>When the liaison feels that the code and explainer are ready, the initiative may be declared &quot;feature complete&quot;.</li>
<li>This is primarily a 'signaling' mechanism to the broader community to encourage testing and feedback.</li>
<li>This is a good phase in which to write the Rust reference chapter and other supporting documentation.</li>
<li>Presuming feedback is positive, a stabilization report is prepared and (hopefully) approved.</li>
</ul>
</li>
<li><a href="initiatives/./process/stages/stabilized.html">Stabilized</a>
<ul>
<li>Done! The Zulip stream can stick around as a place for further discussion, but the initiative is complete. Any Rust team and repository is typically archived.</li>
<li>The final step is to conduct a retrospective discussion between the <a href="initiatives/./process/roles/owner.html">owner</a> and <a href="initiatives/./process/roles/liaison.html">liaison</a> about how the process went.</li>
</ul>
</li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li><strong>Empower individuals and give ownership:</strong>
<ul>
<li>Each initiative in this proposal is ultimately owned by a single person who drafts the proposals and recommendations.</li>
<li>The role of the lang team is to review the designs, provide feedback, and ultimately decide whether to accept the design.</li>
<li>The team can introduce constraints and requests that the owner should either satisfy or explain why they are not able to do so.</li>
</ul>
</li>
<li><strong>Clarify the role of each individual:</strong>
<ul>
<li>As described in the <a href="initiatives/./process/roles.html">roles</a> page, each individual and group involved in an initiative has a clear, defined role in the decision making process.</li>
</ul>
</li>
<li><strong>Minimize friction for &quot;reversible&quot; decisions and enable experimentation:</strong>
<ul>
<li>We avoid requiring &quot;full checkoff&quot; from team members for things that can be readily reversed.</li>
<li>We want to make it relatively easy to start hacking and experimenting with an idea. Under this proposal, all it takes is to find an owner, a liaison, and to have the team leads approve.</li>
<li>Other team members are encouraged to log concerns and constraints that ought to be addressed in the design, rather than blocking experimentation.</li>
</ul>
</li>
<li><strong>Ensure that decisions are truly reversible:</strong>
<ul>
<li>On the flip side, although we wish to make it easy for ideas to move forward, we recognize that this can create a lot of momentum that allows ideas to force their way through the process.</li>
<li>This is why code in the <a href="initiatives/./process/stages/experimental.html">experimental</a> phase issues a warning, for example.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roles"><a class="header" href="#roles">Roles</a></h1>
<p>There are several key roles for any initiative:</p>
<ul>
<li>The <a href="initiatives/process/./roles/owner.html">owner</a> assembles the &quot;menu&quot; of overall solutions to the problem and helps to narrow them down to the most viable.
<ul>
<li>Naturally, they are encouraged to make recommendations on what they consider to be the right choice. These recommendations should include an explanation of what analysis they did on the other options that led them to this recommendation.</li>
</ul>
</li>
<li>The <a href="initiatives/process/./roles/liaison.html">liaison</a> represents the lang team:
<ul>
<li>They guide the owner in picking from the menu. Naturally they may also make suggestions, ask questions, or request that the owner expand or explore a fresh area.</li>
<li>They identify when to involve the full team via a <a href="initiatives/process/../../meetings.html">design meeting</a>.</li>
<li>They keep up to date on the initiative's progress and can summarize its status for other lang team members.</li>
</ul>
</li>
<li>The <strong>lang team members</strong> make the ultimate decision on what changes to accept.
<ul>
<li>They don't typically do the design, though of course they may make suggestions or introduce constriants that the design ought to meet (the owner can argue that these constraints are undesirable).</li>
</ul>
</li>
<li>The <strong>lang team leads</strong> make the ultimate decisions on prioritiziation (which initiatives to pursue).
<ul>
<li>They also help resolve other disputes that fail to come to agreement</li>
</ul>
</li>
</ul>
<p>The owner and liaison are each a single person, though that person can change over time. They cannot both be the same person.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiative-owner"><a class="header" href="#initiative-owner">Initiative owner</a></h1>
<p>The <strong>owner</strong> of an initiative is the person who is ultimately responsible for its design and implementation. They are driving and managing its overall process from conception to completion, though they may work with others to manage pieces of tha process (for example, the implementation is often done by someone else).</p>
<p>The owner is not the decision maker, but they have a huge influence on the design. They assemble the &quot;menu&quot; of overall solutions to the problem and help to narrow the choices down to the ones that are most viable. They are also encouraged to make recommendations on what they consider to be the right choice. These recommendations should include an explanation of what analysis they did on the other options that led them to this recommendation.</p>
<p>Owners do not have to be members of the lang team, but they do have to be sufficiently experienced and dedicated to drive the initiative with minimal assistance. Owning an initiative is also a common stepping stone on the path to full lang team membership.</p>
<h2 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h2>
<ul>
<li>Sufficient experience to perform or mentor the above tasks independently</li>
<li>Demonstrated good judgement</li>
</ul>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>Note that in practice these may be delegated or done in concert with a group:</p>
<ul>
<li>Exploring the design space and preparing the final design</li>
<li>Escalating tricky decisions by defining the 'menu' of choices and alternatives for the team to consider (with recommendations, where appropriate)</li>
<li>Documenting the design space and alternatives that were not chosen (and why)</li>
<li>Interacting with people on Zulip or elsewhere who are offering feedback and ideas, incorporating those ideas where appropriate into the final design</li>
<li>Developing and writing the code for the feature</li>
<li>Documenting the feature in the Rust reference or other sites as appropriate</li>
</ul>
<h2 id="estimated-time-commitment"><a class="header" href="#estimated-time-commitment">Estimated time commitment</a></h2>
<p>The time commitment will vary depending on the initiative. Some initiatives are effectively full-time endeavors (40 hours per week). Others can move along at a pokier pace. For an initiative to be considered <em>active</em>, however, it should have some form of update most months. After several months of inactivity, we will discuss with the owner whether the initiative should be moved to &quot;inactive&quot; state or whether we should seek another owner.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiative-liaison"><a class="header" href="#initiative-liaison">Initiative liaison</a></h1>
<p>The <strong>liaison</strong> for an initiative is a lang team member who is responsible for tracking its progress and giving updates to the lang team. They should also help advise the owner on how to resolve issues and when to seek the feedback of the broader lang team or other stakeholders.</p>
<p>The liaison and the owner cannot be the same person.</p>
<h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<ul>
<li>Mentoring the initiative owner and helping them to decide when facing difficult design decisions.</li>
<li>Preparing a summary for the monthly planning meeting documenting the decisions that were made and why.</li>
<li>Escalating important decisions to the team where appropriate for broader feedback.</li>
<li>Generally serving as a kind of &quot;outside voice&quot; where necessary.</li>
</ul>
<h2 id="pre-requisites-1"><a class="header" href="#pre-requisites-1">Pre-requisites</a></h2>
<ul>
<li>Lang team member</li>
<li>Interest in the initiative and sufficient context to help guide (don't have to be an <em>expert</em>, but should be able to recognize what you don't know)</li>
</ul>
<h2 id="estimated-time-commitment-1"><a class="header" href="#estimated-time-commitment-1">Estimated time commitment</a></h2>
<p>15-30 minutes per week (regular sync meeting) and the occasional deep dive. If the liaison is spending much more time than this, then they may in fact be playing the role of owner, and that is a problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stages-of-an-initiative"><a class="header" href="#stages-of-an-initiative">Stages of an initiative</a></h1>
<p>Presuming that an initiative continues successfully, it will go through the following stages:</p>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Goal</th><th>Permits</th><th>Successful exit</th></tr></thead><tbody>
<tr><td><a href="initiatives/process/./stages/proposal.html">Proposal</a></td><td>Find a team <a href="initiatives/process/./roles/liaison.html">liaison</a></td><td>Discussion</td><td>Team member seconds, thereby agreeing to act as <a href="initiatives/process/./roles/liaison.html">liaison</a></td></tr>
<tr><td><a href="initiatives/process/./stages/experimental.html">Experimental</a><br>(sometimes skipped)</td><td>Refine the design and work towards an RFC</td><td>Active zulip stream; tracking issue / repository; code can land under &quot;unstable&quot; feature gate</td><td>RFC is approved by team</td></tr>
<tr><td><a href="initiatives/process/./stages/development.html">Development</a></td><td>Finalize design and implementation</td><td>Removing the &quot;experimental&quot; tag on a feature</td><td>Liaison declares the proposal feature complete</td></tr>
<tr><td><a href="initiatives/process/./stages/feature_complete.html">Feature complete</a></td><td>Gathering feedback</td><td>Advertisting the initiative as &quot;feature complete&quot;</td><td>Stabilization proposal approved</td></tr>
<tr><td><a href="initiatives/process/./stages/stabilized.html">Stabilized</a></td><td></td><td>Use on stable branch</td><td>(none)</td></tr>
</tbody></table>
</div>
<p>The &quot;experimental&quot; stage can be skipped if the initiative is sufficiently simple that a RFC doesn't seem necessary; see <a href="initiatives/process/stages.html#simple-initiatives">&quot;simple initiatives&quot;</a> below.</p>
<p>Initiatives can also become <a href="initiatives/process/./stages/inactive.html">inactive</a> for a variety of reasons.</p>
<h2 id="simple-initiatives"><a class="header" href="#simple-initiatives">Simple initiatives</a></h2>
<p>The above process is the ideal, but there are alternative routes that occur in practice for simple initiatives. The most common is one that begins with a PR:</p>
<ul>
<li>Implement the idea and open a PR.</li>
<li><a href="initiatives/process/../../how_to/nominate.html">Nominate</a> the PR to the lang team's attention.</li>
<li>The lang team may opt to either approve the PR (skip directly to &quot;feature complete&quot;), assign an owner (skip directly to &quot;development&quot;), or to request a proposal.</li>
</ul>
<h2 id="umbrella-initiatives"><a class="header" href="#umbrella-initiatives">Umbrella initiatives</a></h2>
<p>Some initiatives are broader in scope and are tagged as &quot;umbrella initiatives&quot;. These are far-reaching tasks like &quot;async I/O&quot;. While they have goals, they don't have a clear stage. Instead, they have project boards (and potentially subinitiatives) of their own that track their state.</p>
<h2 id="diagram"><a class="header" href="#diagram">Diagram</a></h2>
<pre><code class="language-mermaid">graph TD
    HaveGoodIdea[Have a good idea]
    FileLangProposal[File proposal issue&lt;br&gt;on lang-team repository]
    RejectWithExplanation[Proposal closed,&lt;br&gt;with an explanation of why]
    Experimental[Expermental: Iterate on design and develop an RFC]
    Development[&quot;Develop implementation&quot;]
    FeatureComplete[&quot;Feature complete&quot;]
    Stabilized[&quot;Stabilization is approved&quot;]

    HaveGoodIdea-- Idea seems ready --&gt;FileLangProposal
    HaveGoodIdea-- iterate on internals/zulip/etc --&gt;HaveGoodIdea

    FileLangProposal-- Concept declined by lang team --&gt;RejectWithExplanation
    FileLangProposal-- Liason seconds, no RFC required--&gt;Development
    FileLangProposal-- Liason seconds, RFC required --&gt;Experimental

    Experimental-- RFC is approved --&gt;Development
    Development -- Iterate and improve design --&gt; Development;
    Development -- Ready for people to experiment --&gt; FeatureComplete;
    FeatureComplete -- Decide to make changes --&gt; Development;
    FeatureComplete -- Prepare stabilization report --&gt; Stabilized;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-1-proposal"><a class="header" href="#stage-1-proposal">Stage 1: Proposal</a></h1>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>The proposal stage is where specific ideas start. To make a new proposal, <a href="https://github.com/rust-lang/lang-team/issues/new/choose">open an &quot;Initiative Proposal&quot; issue on the lang-team repository</a>. It should include:</p>
<ul>
<li>Motivation and general idea</li>
<li>Any relevant background links</li>
<li>Enough detail to understand the problem and some sense of how it might be solved</li>
<li>Someone interested in being the <a href="initiatives/process/stages/../roles/owner.html">owner</a> for the initiative, if any.</li>
</ul>
<p>Proposals are meant to be raised early. The idea should have undergone some amount of iteration, perhaps on internals or elsewhere, but it doesn't have to be -- and ideally is not -- a fully formed, concrete proposal. It can be a sketch of &quot;here is a problem and here are a few general ideas for how to address it&quot;.</p>
<p>Once a proposal is opened, it can be discussed asynchronously by lang team members. If some member likes the idea, they first check with the team leads. If the leads agree, the member can <strong>second</strong> it, which means the member agrees to serve as the lang team <a href="initiatives/process/stages/../roles/liaison.html">liaison</a>.</p>
<ul>
<li>Proposal does not have to include:
<ul>
<li>Specific details or a known plan, uncertainty is expected</li>
</ul>
</li>
<li>Lang team members will review, consider, and discuss</li>
</ul>
<p>While a proposal is open, it can undergo refinements simply by editing the issue text. Discussions typically take place on Zulip, but it is expected that regular summaries will be posted.</p>
<h2 id="timeframe"><a class="header" href="#timeframe">Timeframe</a></h2>
<p>Proposals represent pending decisions and are not meant to stay open. The decision about whether to accept a proposal or not is typically made within 1-2 weeks and is meant to decided within one month. In some cases, we may close a proposal but continue discussing and decide to open a fresh proposal shortly thereafter.</p>
<h2 id="exit-seconding-a-proposal"><a class="header" href="#exit-seconding-a-proposal">Exit: Seconding a proposal</a></h2>
<p>Any team member can <strong>second</strong> a proposal: this means that they volunteer to serve as initiative <a href="initiatives/process/stages/../roles/liaison.html">liaison</a>. Before seconding a proposal:</p>
<ul>
<li>The proposed owner should ensure that all relevant conversation from the Zulip threads, internals forum, and other forums is summarized in the issue.
<ul>
<li>If they are not willing/able to do this, they are likely not a good choice to act as owner.</li>
</ul>
</li>
<li>The liaison should check with the team lead(s).
<ul>
<li>This gives the leads a chance to discuss whether the initiative seems like a good fit and whether the proposed initiative owner/liaison is a good choice (and, if not, why not).</li>
<li>Team lead(s) should check with the moderation team to see if the proposed owner (or prominent likely members) has any prior history that may not be known to them. The leads do this to keep this info on a narrow basis.</li>
<li>It's better to have those kind of sensitive discussions before things have been said publicly.</li>
</ul>
</li>
</ul>
<p>After this is done, members may second the proposal by writing <code>@rustbot second</code> in the issue thread along with a short comment identifying the owner. Seconding a proposal will cause it enter an FCP period. Team members may opt to suspend the FCP period by issuing <code>@rustbot pause</code>, this will cause the FCP to suspend. This is typically done to raise a concern which can then be discussed. The FCP can be resumed by any member saying <code>@rustbot resume</code> (to re-enter FCP) or <code>@rustbot cancel</code> (to cancel FCP).</p>
<p>Once a proposal is seconded, the next step depends on its complexity:</p>
<ul>
<li>Most initiatives proceed to <a href="initiatives/process/stages/./experimental.html">Stage 2 (Experimental)</a>, which is focused on authoring an RFC.</li>
<li>However, simple initiatives can skip directly to <a href="initiatives/process/stages/./development.html">Stage 3 (Development)</a>.
<ul>
<li>This indicates that the design is well understood and there aren't any complex tradeoffs to explore and document.</li>
<li>A common example of this is for new lints.</li>
</ul>
</li>
</ul>
<p>Types of objections that make sense at this period:</p>
<ul>
<li>Technical concerns:
<ul>
<li>These are typically managed by adding the scenario or concern to a list of constraints to be taken under consideration and addressed.</li>
<li><strong>It is absolutely not necessary to have answers to all the technical problems before seconding a proposal!</strong></li>
</ul>
</li>
<li>Overload concerns:
<ul>
<li>A single owner or liaison should not be involved in too many things.</li>
</ul>
</li>
<li>Prioritization concerns:
<ul>
<li>This idea might seem premature or like a poor choice of resources.</li>
</ul>
</li>
<li>People concerns:
<ul>
<li>Concerns about the people involved are best raised by taking directly to the leads first.</li>
</ul>
</li>
</ul>
<h2 id="exit-proposal-is-not-accepted"><a class="header" href="#exit-proposal-is-not-accepted">Exit: Proposal is not accepted</a></h2>
<p>In some cases, proposals will not be accepted. This could happen because there is nobody who wants to second it at this time. It could also happen because the lang team leads decide that the proposal doesn't it the current priorities of the team, or because the lang team leads feel that the task is not a good fit for the proposed owner or liaison (for example, the task may require specialized skills or more time than they have available). In these cases, the proposal will be closed.</p>
<p>We typically do not close proposals just because lang team members have technical objections: instead, those objections can be logged and resolved through the experimentation period. However, if it is clear that the proposal has no pathway to being accepted, we would try to take that into account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-2-experimental-optional"><a class="header" href="#stage-2-experimental-optional">Stage 2: Experimental (optional)</a></h1>
<p>If an initiative is sufficiently complex as to warrant an RFC, then, after being seconded, the initiative enters the &quot;experimental&quot; state. The goal at this stage is to iterate on exploring and documenting the design space and preparing an RFC, or even multiple RFCs. These initiatives have their own Zulip stream and can land code in the compiler.</p>
<p>Being in the experimental stage does not represent a commitment to land the code. There may well be team members with very live concerns about the feature and it may well get removed if those concerns cannot be resolved.</p>
<p>Initiatives in the experimental stage can have the following resources:</p>
<ul>
<li>Their own dedicated Zulip stream (<code>#project-xxx</code>)</li>
<li>A tracking issue</li>
<li>A repository if desired</li>
<li>They can land code in the compiler under an &quot;experimental&quot; feature gate (i.e., one that warns when you use it)
<ul>
<li>Ideally we would warn that this represents an early stage, &quot;experimental&quot; proposal</li>
</ul>
</li>
</ul>
<h3 id="skipping-this-stage"><a class="header" href="#skipping-this-stage">Skipping this stage</a></h3>
<p>Some initiatives are rather simple. In that case, we can skip this &quot;experimental&quot; stage and go straight towards development without authoring an RFC. This often applies to small tweaks in the language, or to things like adding a new lint.</p>
<h3 id="advertising-that-a-feature-is-experimental"><a class="header" href="#advertising-that-a-feature-is-experimental">Advertising that a feature is experimental</a></h3>
<p>Feature development that occurs in the experimental stage is very tentative. We must take care to ensure that users are aware of this. All feature gates related to &quot;experimental&quot; initiatives need to be flagged as experimental and issue a suitable warning to users. Furthermore, the &quot;unstable book&quot; page for the features should indicate that they are currently experimental and do not yet have an accepted RFC.</p>
<h3 id="during-this-stage-updates-to-the-team"><a class="header" href="#during-this-stage-updates-to-the-team">During this stage: updates to the team</a></h3>
<p>During this stage, the owner and the liaison should meet on a regular basis. The owner should update the liaison about major design directions and seek their guidance on complex issues (particularly if the owner is not a member of the team). The liaison is responsible for documenting these updates and preparing a monthly update to the team as a whole. They are also responsible for deciding when an issue should be escalated to a lang team design meeting. Sometimes it makes sense to have a design meeting even if there isn't a decision to be made, just to update the team about the overall progress.</p>
<h3 id="exit-rfc-approval"><a class="header" href="#exit-rfc-approval">Exit: RFC approval</a></h3>
<p>To exit the Experimental stage, you typically need to prepare an RFC on the rust-lang/rfcs repository. This RFC needs to be approved by the lang team. The RFC can include &quot;unresolved questions&quot; to be resolved during the &quot;development&quot; phase.</p>
<h3 id="exit-go-inactive"><a class="header" href="#exit-go-inactive">Exit: Go inactive</a></h3>
<p>It often happens that initiatives &quot;stall out&quot;. This could be because some of the problems seem insurmountable, because the people involved wind up not having enough time to continue, or because other things take priority. At any point, the owner can decide to step back, at which point the initiative becomes <a href="initiatives/process/stages/./inactive.html">inactive</a>. If an initiative has not made progress in several months, the team may also opt to move it to inactive status.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-3-development"><a class="header" href="#stage-3-development">Stage 3: Development</a></h1>
<p>After an RFC is approved, the initiative enters &quot;development&quot; stage. The only difference from the &quot;experimental&quot; stage is that the feature gate can now be marked as &quot;non-experimental&quot; and hence used without any sort of warning.</p>
<p>During this stage, the focus is on implementing the complete feature and on resolving any unresolved features.</p>
<h2 id="exit-group-declares-feature-feature-complete"><a class="header" href="#exit-group-declares-feature-feature-complete">Exit: Group declares feature &quot;feature complete&quot;.</a></h2>
<p>At some point, the group can declare a feature to be &quot;feature complete&quot;. This requires the following materials to be available:</p>
<ul>
<li>Accessible documentation in the &quot;unstable Rust&quot; user's guide, if appropriate.</li>
<li>All unresolved questions from the RFC have documented answers.</li>
<li>Tests are written covering all major points in the RFC.
<ul>
<li>Ideally, those tests should be documented, as well, though we don't have a real convention here.</li>
</ul>
</li>
</ul>
<h2 id="exit-go-inactive-1"><a class="header" href="#exit-go-inactive-1">Exit: Go inactive</a></h2>
<p>It often happens that initiatives &quot;stall out&quot;. This could be because some of the problems seem insurmountable, because the people involved wind up not having enough time to continue, or because other things take priority. At any point, the owner can decide to step back, at which point the initiative becomes <a href="initiatives/process/stages/./inactive.html">inactive</a>. If an initiative has not made progress in several months, the team may also opt to move it to inactive status.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-4-feature-complete"><a class="header" href="#stage-4-feature-complete">Stage 4: Feature complete</a></h1>
<p>&quot;Feature complete&quot; initiatives are awaiting community experimentation and stabilization. Typically this is done by writing a blog post (on Inside Rust, perhaps) encouraging experimentation and feedback. That feedback should be gathered and summarize in the monthly reports. It is particularly useful to have lists of users.</p>
<p>The owner should continue to meet regularly with the liaison at this time, though the meeting frequency is often just once a month and quite short.</p>
<h2 id="entry-criteria"><a class="header" href="#entry-criteria">Entry criteria</a></h2>
<p>Entering the &quot;feature complete&quot; stage typically requires that there is documentation available to users about how the feature works overall (but not necessarily detailed reference material):</p>
<ul>
<li>Liaison agrees that the feature is feature complete.</li>
<li>An explainer is prepared that explains to end-users how the feature works.</li>
<li>A blog post, linking to the explainer, that announces progress and requests testing and feedback.</li>
</ul>
<p>In addition, it's a good place to explain how any &quot;unresolved questions&quot; from the RFC would up being resolved.</p>
<h2 id="preparing-reference-documentation"><a class="header" href="#preparing-reference-documentation">Preparing reference documentation</a></h2>
<p>In addition to evaluating the feature, this is a good period to prepare &quot;reference&quot; documentation that explains the changes in depth. This is typically included in the <a href="https://doc.rust-lang.org/reference/">Rust reference</a> but may appear in other documentation as well, such as the Necronomicon. These changes will be reviewed as part of the stabilization report and will land after the feature is stabilized.</p>
<h2 id="exit-stabilization-report-prepared-and-approved"><a class="header" href="#exit-stabilization-report-prepared-and-approved">Exit: Stabilization report prepared and approved</a></h2>
<p>To exit the stage, the owner prepares a stabilization report. Stabilization reports follow the templat and generally give details about:</p>
<ul>
<li>Final design of the feature
<ul>
<li>In particular, how were unresolved questions or other details from the RFC resolved?</li>
</ul>
</li>
<li>What is tested and where</li>
<li>Link to the Rust reference materials or other documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-5-stabilized"><a class="header" href="#stage-5-stabilized">Stage 5: Stabilized</a></h1>
<p>This is the final stage. The development is done and support transitions to the regular team members. The initiative is now considered <a href="initiatives/process/stages/inactive.html">inactive</a>. However, the stream often sticks around as a convenient place to ping the people who were involved in implementing the feature for follow-up questions and for fixing bugs or other maintenance. The expectation is that if you helped to develop a feature, you will stay involved for some period of time after it hits stable to help in resolving problems that arise.</p>
<p>After stabilization, the owner and liaison should meet to do a final retrospective on how everything went and what could have been improved. This should be done within a few weeks of stabilization, while the memories are fresh.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inactive-groups"><a class="header" href="#inactive-groups">Inactive groups</a></h1>
<p>As an alternative to stabilization, initiatives may become <em>inactive</em>. This could be because we decided the idea doesn't work, but it could also be that people just no longer had time to work on it and so the idea was paused until somebody else shows up with time and energy. When marking an initiative as inactive, we try to do a final retrospective that judges how well the experience went. We also try to prepare a summary of the final state in case someone wants to start working on the design again (or perhaps a small piece of it; a common failing for initiatives is trying to tackle too big of a problem). These technical summaries can be placed in the <a href="initiatives/process/stages/../../../design_notes.html">design notes</a> section of this website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklists"><a class="header" href="#checklists">Checklists</a></h1>
<p>Here are some checklists of the exact procedural steps to take.</p>
<h2 id="open-a-proposal"><a class="header" href="#open-a-proposal">Open a proposal</a></h2>
<ul>
<li><a href="initiatives/process/./roles/owner.html">Owner</a> should <a href="https://github.com/rust-lang/lang-team/issues/new/choose">open an &quot;Initiative Proposal&quot; issue on the lang-team repository</a>.</li>
</ul>
<h2 id="second-a-proposal"><a class="header" href="#second-a-proposal">Second a proposal</a></h2>
<ul>
<li>If there has been significant conversation, <a href="initiatives/process/./roles/liaison.html">liaison</a> should ask <a href="initiatives/process/./roles/owner.html">owner</a> to summarize that on the issue.</li>
<li><a href="initiatives/process/./roles/liaison.html">Liaison</a> should write <code>@rustbot second</code> which will trigger the start of the 10-day Final Comment Period (FCP).</li>
<li>Any lang team member who has concerns should leave them in Zulip and on the issue during the final comment period.
<ul>
<li>Owner and liaison are responsible to describe how they expect to resolve the concern. This can be something simple, like &quot;we will do a write-up and a design meeting on this point&quot;.</li>
</ul>
</li>
</ul>
<h2 id="approve-a-proposal"><a class="header" href="#approve-a-proposal">Approve a proposal</a></h2>
<p>Once a proposal has been seconded and the FCP has expired:</p>
<ul>
<li>If the initiative wants its own repository, then open an issue on the <a href="https://github.com/rust-lang/infra-team/">infra-team repository</a> and request that the infra team clone the <a href="https://github.com/rust-lang/initiative-template">initiative-template repository</a> with whatever name you need (<code>your-initiative-here</code>).</li>
<li>Create a tracking issue to track the initiative:
<ul>
<li>If should be on <code>rust-lang/your-initiative-here</code> if you have a repository</li>
<li>Otherwise it should be <code>rust-lang/rust</code> or <code>rust-lang/lang-team</code></li>
<li>Tag it with <code>C-tracking-issue</code> and <code>T-lang</code></li>
</ul>
</li>
<li>Add the tracking issue to the <a href="https://github.com/orgs/rust-lang/projects/16/">project board</a>:
<ul>
<li>Set the status appropriately (typically &quot;experimental&quot;).</li>
</ul>
</li>
<li>If necessary, add a feature-gate to the compiler and tag it as &quot;experimental&quot;.</li>
<li>Close the proposal issue with a link to the tracking issue.</li>
</ul>
<h2 id="close-a-proposal"><a class="header" href="#close-a-proposal">Close a proposal</a></h2>
<ul>
<li>After 4 weeks without a second, rustbot will post (not yet implemented) and add &quot;disposition-close&quot; and &quot;final-comment-period&quot;:
<ul>
<li>&quot;Hi there @rust-lang/lang and @author! It has been 4 weeks and this initiative has not been seconded. Initiatives that are not seconded after 6 weeks are automatically suggested for closure. Members of @rust-lang/lang, please take a look and see if you want to second this! -- your friendly neighborhood rustbot&quot;</li>
</ul>
</li>
<li>After 6 weeks without a second, rustbot will post the following and add &quot;timer-elapsed&quot;
<ul>
<li>&quot;Hi there @rust-lang/lang and @author! It has been 6 weeks and this initiative has not been seconded. It seems that there isn't bandwidth to take up this proposal right now. I am tagging this issue to be closed at the next triage meeting. Please feel free to reopen it in the future when more bandwidth is available, especially if you are able to find a lang team member who says they will second it. -- your friendly neighborhood rustbot&quot;</li>
</ul>
</li>
<li>Human can then close the issue from the triage meeting with comment sort of like:
<ul>
<li>&quot;Thanks for the proposal @author. Unfortunately there wasn't a second at this time and so I am going to close the issue.&quot;</li>
</ul>
</li>
</ul>
<h2 id="exit-the-experimental-stage-and-enter-development-stage"><a class="header" href="#exit-the-experimental-stage-and-enter-development-stage">Exit the <a href="initiatives/process/./stages/experimental.html">experimental</a> stage and enter <a href="initiatives/process/./stages/development.html">development</a> stage</a></h2>
<ul>
<li>Write an RFC</li>
<li>Get the RFC approved</li>
<li>xxx fill this in</li>
</ul>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions-about-initiatives"><a class="header" href="#frequently-asked-questions-about-initiatives">&quot;Frequently asked questions&quot; about initiatives</a></h1>
<h2 id="does-the-initiative-owner-make-decisions"><a class="header" href="#does-the-initiative-owner-make-decisions">Does the initiative owner make decisions?</a></h2>
<p>The initiative owner drafts the proposed design and takes feedback from the liaison and team about what direction to take. This feedback can take the form of &quot;you need to do X&quot;, but typically it is more about &quot;you need to address this scenario&quot;. Or, put another way, if the initiative owner doesn't like the proposed direction, it's up to them to find an alternative that they do like which meets those same constraints, or to argue why the constraints are not necessary.</p>
<p>Note that serving as initiative owner is a high level of responsibility and may not be a good &quot;starting place&quot; for involvement within the Rust project. In practice, initiative owners should be experienced enough that they could mentor others to do the implementation work. If you don't know the language or system well enough to do that, then you probably are not ready to be an owner -- but you may be ready to be mentored by the owner!</p>
<h2 id="is-the-word-of-a-lang-team-member-law"><a class="header" href="#is-the-word-of-a-lang-team-member-law">Is the word of a lang team member law?</a></h2>
<p>Of course not. Well, ok, sometimes. For the most part, initiative owners are encouraged to treat lang team members like any other member of the community -- this implies a lot of respect for their opinions, since they are experienced, knowledgeable people, but the initiative owner still ultimately owns the design and should use their own judgement about what things to recommend. However, lang team members do have the option of adding constraints that must be met, and they can override the initiative owner if necessary. That is typically done by raising the concern with the rest of the team/leads in a more formal way.</p>
<h2 id="what-happens-if-an-owner-stops-working-on-things"><a class="header" href="#what-happens-if-an-owner-stops-working-on-things">What happens if an owner stops working on things?</a></h2>
<p>Initiative owners are often volunteers and may have changes in priorities or find they don't have as much time as they thought they did. In that case, they can simply step back. The liaison can then either find a new initiative owner, or perhaps assume initiative owner duties themselves but find a new liaison. If they are not able to do that, the initiative will be closed as &quot;paused&quot;.</p>
<h2 id="what-if-we-decide-a-initiative-is-a-bad-idea"><a class="header" href="#what-if-we-decide-a-initiative-is-a-bad-idea">What if we decide a initiative is a bad idea?</a></h2>
<p>Sometimes, in the course of trying to design a initiative, we decide it was the wrong direction. That's ok! At any point the liaison can decide that the initiative isn't working out and close it. However, in doing so, they should document WHY they feel it did not work out -- and identify potential conditions where the idea may make sense later on. This documentation will typically take the form of a <a href="initiatives/../design_notes.html">design note</a> in the lang-team repository.</p>
<p>If there are concerns about this, those concerns can be raised with the lang team leads.</p>
<p>Closed initiatives will be removed from the project board and the code for them will be removed from the compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section documents the work-in-progress Rust language team decision
process. This process, and the <code>rustbot</code> tooling to support it, does not yet
have a finished implementation. This document serves to explain the intended
process, for the purposes of ongoing implementation.</p>
<h2 id="prioritized-principles-of-rust-team-consensus-decision-making"><a class="header" href="#prioritized-principles-of-rust-team-consensus-decision-making">Prioritized principles of Rust team consensus decision-making</a></h2>
<p>These are in order of priority. They're intended to be general enough that they
could apply to any Rust governance team, not just the language team.</p>
<ul>
<li><strong>Treasure dissent.</strong> When someone raises a concern, that's a chance to
improve the design, and to discover and explore underlying values. Dissent
should be an amicable, cooperative process.</li>
<li><strong>Understand and cooperatively resolve concerns.</strong> We cannot resolve a
concern without first understanding it, including the underlying values
motivating it. We should demonstrate that understanding by documenting the
concern. We should consider the tradeoffs and the impacts on users, through
the Rust design principles. We should seek out and favor satisfying solutions
(those that satisfy everyone's values) over
<a href="https://en.wikipedia.org/wiki/Satisficing">satisficing</a> solutions (those
that are just good enough for people to accept them as a compromise among
conflicting values, without actually being happy with the outcome).</li>
<li><strong>Don't force an irreversible decision.</strong> We should make decisions
reversible whenever we can. When making a necessarily irreversible decision
(e.g. stabilizing a feature), we should pay close attention to dissent, and
hesitate before overriding objections. If possible, we should seek a better
alternative, or seek common ground we can find consensus on, or seek an
intermediate step that addresses the same use case and supports evaluation
for a more informed decision in the future. If none of those are possible,
consider the null alternative; not making a change should always be the
easier path, and the burden of proof to override a concern on an irreversible
decision should be high.</li>
<li><strong>Value expertise.</strong> When cooperatively resolving a concern, or when
considering overriding a concern, carefully weigh the advice and
recommendations of experts. This includes team advisors, domain experts, and
the owners or members of relevant initiatives.</li>
<li><strong>Recording reasoning helps ensure good, consistent decisions over time.</strong>
Even if we decide not to sustain an objection, we should always record the
objection and the reasons for our decision as a &quot;dissent&quot;, as well as any
unresolved questions for evaluation later in the process. The team member who
raised the objection has the perogative to author that dissent and frame the
unresolved questions (within reason).</li>
<li><strong>Consensus doesn't mean unanimity.</strong> Consensus means everyone is heard and
understood, and all concerns are addressed (even those not treated as
blocking), and the team finds the outcome reasonable. Consensus does not mean
everyone agrees completely.</li>
</ul>
<h2 id="consensus-decision-making-process"><a class="header" href="#consensus-decision-making-process">Consensus decision-making process</a></h2>
<p>First, see <a href="./decision_process/examples.html">some examples of the decision-making process in
action</a>. Then, read the <a href="./decision_process/reference.html">decision process
reference</a> for the full process and the
<code>rustbot</code> tooling to support it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-the-decision-making-process-in-action"><a class="header" href="#examples-of-the-decision-making-process-in-action">Examples of the decision-making process in action</a></h1>
<h2 id="reversible-decision-merging-a-proposal"><a class="header" href="#reversible-decision-merging-a-proposal">Reversible decision: merging a proposal</a></h2>
<p>The process is best described by example. Suppose that there is a pending lang
team proposal, and a lang team member would like to serve as the liaison. They
contact the team leads and receive the go-ahead. They can then write:</p>
<blockquote>
<p>@rustbot merge</p>
<p>I propose to merge this proposal. I think it will be a great addition to
Rust!</p>
</blockquote>
<p>This indicates that they would like to merge the proposal. At the moment, there
is no decision pending, so rustbot would add a comment that looks like the
following:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or
cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>As the comment says, the PR is now in &quot;pending decision&quot; state, with Alan
having kicked off the process with a proposal to merge. Alan's status of
<strong>merge</strong> will link to his comment.</p>
<p>Now, for this particular proposal, Barbara has a concern. She thinks that the
proposal has overlooked an important consideration. She writes a comment:</p>
<blockquote>
<p>@rustbot hold</p>
<p>Did you consider reversing the polarity? Or the impact on the flux capacitor?</p>
</blockquote>
<p>At this point, rustbot updates the state; Barbara's status of
<strong>hold</strong> will link to her comment:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><strong>hold</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>Alan is currently busy at work, though, so by the time that he and Barbara
get a chance to talk, 11 days have passed. (Alan and Barbara receive a ping
from rustbot after a week or so.) Once they get a chance to talk, Alan
fully addresses Barbara's concern, so Barbara posts:</p>
<blockquote>
<p>@rustbot merge</p>
</blockquote>
<p>The comment is updated:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>hold</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>Barbara's previous <del>hold</del> status links to her previous comment setting her
status to <code>hold</code>, and her current <strong>merge</strong> status links to her more recent
comment setting her status to <code>merge</code>.</p>
<p>At this point, all the statuses are either empty or <strong>merge</strong>, and more than 10
days have passed since the FCP started. Therefore, it completes immediately.</p>
<h2 id="authoring-an-rfc-illustration-of-rustbot-restart"><a class="header" href="#authoring-an-rfc-illustration-of-rustbot-restart">Authoring an RFC (illustration of <code>rustbot restart</code>)</a></h2>
<p>After some time, the proposal is completed and an RFC is proposed. This is a
reversible decision. Alan, as the liaison, proposes to merge the RFC with
<code>@rustbot merge</code>, and the decision making process proceeds as above.</p>
<p>This time, Niklaus has a concern:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I have not had time to read this yet! Give me a bit of time to write it up.</p>
</blockquote>
<p>After 7 days have passed, rustbot writes to him:</p>
<blockquote>
<p>@Niklaus, I see you have placed a hold but 7 days have passed. Are you any
closer to reaching a decision? (cc @Alan)</p>
</blockquote>
<p>This continues for a week or two while Alan and Niklaus play &quot;email tag&quot;. In
the interim, Barbara decides she agrees with the RFC, so she uses <code>@rustbot merge</code> as well. The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this PR. This is a <strong>reversible
decision</strong>, which means that it will be affirmed once the &quot;final comment
period&quot; of 10 days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).
decision.</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><strong>merge</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td><strong>hold</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Eventually, Alan and Niklaus find a time to discuss, and Alan agrees that
Niklaus's concerns are valid, so he makes some major edits to the RFC. Given
that the RFC is completely different, he decides to restart the clock and
writes:</p>
<blockquote>
<p>@rustbot restart</p>
</blockquote>
<p>This strikes through the state of all team members (setting their current
status to blank, while preserving the history) and begins the clock anew.
rustbot also pings the relevant team members:</p>
<blockquote>
<p>Dear @rust-lang/team, @Alan has restarted the clock!</p>
</blockquote>
<p>The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del></td></tr>
</tbody></table>
</div></blockquote>
<p>Barbara can use <code>@rustbot merge</code> to re-affirm her <strong>merge</strong> status, and Niklaus
can use <code>@rustbot merge</code> to set his own status to <strong>merge</strong> since he agrees
with the resolution of his concern.</p>
<h2 id="authoring-an-rfc-continued-overriding-a-concern"><a class="header" href="#authoring-an-rfc-continued-overriding-a-concern">Authoring an RFC continued (Overriding a concern)</a></h2>
<p>At this point, Grace has a concern, and explains that concern in detail:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I've thought about this a lot, and I don't think we should do this. Now that
I see the syntax used in practice, I feel like if we do this it'll have an
adverse effect on the ecosystem...</p>
</blockquote>
<p>The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><strong>hold</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Niklaus reads this message. He feels he understands the concern well, and
agrees that this point hasn't yet been considered:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I agree. I think we should take more time to evaluate alternative syntaxes.
What about...</p>
</blockquote>
<p>Over the course of a few subsequent meetings and side conversations, Grace and
other team members discuss the concern further; the initiative owner also
considers the concern, and raises it with others working on the initiative.</p>
<p>The owner of the initiative updates the RFC to include a discussion of a couple
of alternative syntax proposals. The owner recommends a slightly modified
version of the originally proposed syntax, and outlines criteria that they feel
the syntax should meet in order to support the use case.</p>
<p>Grace agrees that her concern has been understood, but does not agree with the
proposed syntax. Grace feels the new proposal is an improvement, but her
concern remains.</p>
<p>Niklaus feels that the team has understood Grace's concern, and furthermore,
that the updated proposal addresses Grace's concern:</p>
<blockquote>
<p>@rustbot merge</p>
<p>I appreciate the potential impact this may have on the ecosystem. However, I
feel that as now described in section XYZ of the RFC, the value of A
outweighs the risk of B, and I think C mitigates the potential risk by...</p>
</blockquote>
<p>(Notice that while Niklaus feels that the team has understood Grace's concern,
he does not speak for the entire team or imply that his summary represents the
entire team. Niklaus is just withdrawing his own support for the concern.)</p>
<p>At this point, the entire team other than Grace agrees that the proposal should
move forward:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><strong>hold</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <del>merge</del> <del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>(We'll assume, for this example, that Grace does not manage to convince anyone
else.)</p>
<p>Grace takes some time, working with the RFC author, to add a dissent, including
a specific unresolved question.</p>
<p>Grace then writes a comment containing <code>@rustbot dissent</code>. (If necessary, or if
Grace would prefer, another team member may issue <code>@rustbot @grace dissent</code> on
her behalf.) The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><del>hold</del> <strong>dissent</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <del>merge</del> <del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Since all statuses are now either <strong>merge</strong> or <strong>dissent</strong> rustbot also posts a
comment:</p>
<blockquote>
<p>The final comment period has resolved, with a decision to <strong>merge</strong>.</p>
<p>Note that this decision has dissents; please ensure these dissents have been
recorded for subsequent consideration.</p>
</blockquote>
<h2 id="stabilizing-a-feature"><a class="header" href="#stabilizing-a-feature">Stabilizing a feature</a></h2>
<p>The feature has been implemented and is now eligible for stabilization. Alan
writes a stabilization report and posts it, and then issues the command</p>
<blockquote>
<p>@rustbot stabilize</p>
</blockquote>
<p>Rustbot recognizes that a &quot;stabilization&quot; decision is irreversible, so the
template is a bit different:</p>
<blockquote>
<p>Hello! @Alan has proposed to stabilize this. This is a <strong>irreversible
decision</strong>, which means that it will be affirmed once all members come to a
consensus and the &quot;final comment period&quot; of 10 days has passed.</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td>stabilize</td></tr>
<tr><td>@Barbara</td><td></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>This time, Barbara, Grace, and Niklaus must all explicitly provide a status
before the decision can proceed. One by one, they join the PR. They must
individually set their state using one of the rustbot commands.</p>
<p>Niklaus reads this and comments with <code>@rustbot merge</code>. But then, Niklaus uses
the feature and discovers a crucial flaw. He posts a comment:</p>
<blockquote>
<p>@rustbot close</p>
<p>After more testing, I believe this is not ready for stabilization. I have
found that it doesn't work at all like the specification in the case of foo!
This seems closely related to Grace's concern on the RFC; I think if we
stabilize at this point we may indeed harm the ecosystem...</p>
</blockquote>
<p>Other team members test as well, and find that Niklaus is right. Alan changes
his status using <code>@rustbot close</code>, and Grace (with some relief) sets the same
status.</p>
<p>Once everyone has changed their status, rustbot posts a comment:</p>
<blockquote>
<p>The final comment period has resolved, with a decision to <strong>close</strong>.</p>
</blockquote>
<p>(Note: Since <code>close</code> is an inherently reversible status (a PR can always be
reopened), rustbot can observe that everyone has set a reversible status, and
will start treating the decision as reversible; this means the final comment
period can end even if Barbara hasn't responded yet.)</p>
<p>This may not be the end of this feature's consideration, and the concern might
get resolved in many different ways. The initiative owner might need to do some
additional design work on how to solve the original use case and address the
concern; implementers may find a way to address the concern by improving the
implementation; or the team may change their mind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decision-making-process-detailed-description"><a class="header" href="#decision-making-process-detailed-description">Decision-making process, detailed description</a></h1>
<ul>
<li>Entering a &quot;decision period&quot; can be done by having a team member tell rustbot
an initial status (<code>merge</code>, <code>stabilize</code>, or <code>close</code>; or, <code>reversible</code> or
<code>irreversible</code> with a custom identifier).
<ul>
<li>All other team members have no initial status set.</li>
<li>During a reversible decision period, if later commenters indicate the
decision is irreversible, the decision changes to irreversible.</li>
<li>During an irreversible decision period, if all commenters change their
status to a reversible status (most commonly <code>close</code>), the decision becomes
reversible.</li>
<li>Bot commands accept <code>mut</code>/<code>mutable</code>/<code>rev</code> as synonyms for <code>reversible</code>, and
<code>immut</code>/<code>immutable</code>/<code>irrev</code> as synonyms for <code>irreversible</code>.</li>
</ul>
</li>
<li>Once the &quot;decision period&quot; has begun, a clock of 10 days starts. The clock is
never paused unless an explicit <code>@rustbot restart</code> command is given.</li>
<li>The <code>restart</code> command sets the decision period back to its initial state
(members' current statuses are also set back to blank, though the history of
their previous statuses is preserved as with any other status change).</li>
<li>A decision is reached when the following conditions are met:
<ul>
<li>At least 10 days have elapsed since the decision period began (or when it
was last <code>restart</code>ed).</li>
<li>Everyone is set to the same status, or to <code>abstain</code>, or to <code>dissent</code> (with
at most one <code>dissent</code> status), or (for a reversible decision only) blank.</li>
</ul>
</li>
<li>Member may place a <em>hold</em> (raise a concern) at any phase of the process:
proposal, experimentation, testing, stabilization. Ideally, concerns should
be raised as early as possible.
<ul>
<li>In general, one of the liaison's jobs is to anticipate concerns that may
arise and reach out proactively to the members of the team. If we find that
team members regularly need to place serious holds for similar reasons,
that may indicate we need to work harder at team calibration.</li>
</ul>
</li>
<li>&quot;Holding&quot; a decision is simple. If you have a potential concern that you
haven't had a chance to fully articulate yet, you get periodic pings.</li>
<li>In order to proceed after a concern is raised, whether sustaining the concern
or overriding the concern, the team must understand the concern. This
understanding should be expressed in writing rather than just verbally.
Commonly, the owner of an initiative/proposal may incorporate the concern
into the proposal and address it there (whether via their own words or those
of a team member).
<ul>
<li>Ideally, a concern is only considered &quot;understood&quot; if the objector agrees
it has been. If that is not possible, then everyone on the team other than
the objector must unanimously agree that there is no further understanding
to be gained. (In practice, this agreement is determined by whether anyone
on the team is willing to support the objection.)</li>
</ul>
</li>
<li>If the owner feels that the concern has been adequately addressed, they can
produce a write-up that describes the concern and request a poll of the team
members to see where everyone stands.
<ul>
<li>Sustaining an objection requires one team member other than the objector. A
team member should sustain an objection if either they believe the
objection has been understood and they agree that it must be addressed, or
if they believe the objection has not been fully understood (whether they
personally agree with it or not).</li>
<li>If everyone else agrees that the concern has been understood <em>and</em> that the
current design is sufficient, then the concern is <em>overridden</em>.</li>
<li>Team members are encouraged to regularly sustain objections they don't
personally agree with, if they believe the objection has not yet been fully
understood; this is a normal and valuable part of the process.</li>
</ul>
</li>
<li>Whenever a concern is overridden, team members are encouraged to add a
<strong>dissent</strong> into the document to describe their concern and why they don't
agree with the decision. They (or another team member) should then set their
status to <code>dissent</code>.</li>
</ul>
<h1 id="rustbot-commands"><a class="header" href="#rustbot-commands">Rustbot commands</a></h1>
<p>The following commands are accepted by rustbot. (Commands written below omit
the required <code>@</code> on rustbot to avoid invoking rustbot when quoting the
documentation.) A number of comments take one or more optional <code>@member</code>
arguments, denoted <code>@member*</code>; if supplied, the command is issued on behalf of
those member(s), instead of the person writing the command. (The <code>@</code> for each
member is required.) It is also permitted to write <code>@rust-lang/team</code> to select
all members of the team. rustbot will always link from each member's row in the
table to each comment changing their status.</p>
<ul>
<li><code>rustbot @member* reversible ident</code> or <code>rustbot @member* mutable ident</code>
(unambiguous prefixes such as <code>mut</code> or <code>rev</code> also work)
<ul>
<li>If not in a decision period: begin a reversible (&quot;mutable&quot;) decision,
proposing the outcome <code>ident</code>; all other members are set to a blank status.</li>
<li>If in a decision period: set yourself to <code>ident</code>. (Decisions do not proceed
unless all members have the same status or <code>abstain</code>.)</li>
</ul>
</li>
<li><code>rustbot @member* irreversible ident</code> or <code>rustbot @member* immutable ident</code>
(unambiguous prefixes such as <code>immut</code> or <code>irrev</code> also work)
<ul>
<li>If not in a decision period: begin an irreversible (&quot;immutable&quot;) decision,
proposing the outcome <code>ident</code>; all other members are set to a blank status.</li>
<li>If in a decision period: set yourself to <code>ident</code>. If the decision was
previously considered reversible, change it to irreversible. The decision
now requires full team consensus. (Members may set a status of <code>abstain</code> on
the decision if they wish.)</li>
</ul>
</li>
<li><code>rustbot @member* merge</code>
<ul>
<li>Alias for <code>rustbot @member* reversible merge</code> - a reversible decision with
the proposed outcome <code>merge</code>.</li>
</ul>
</li>
<li><code>rustbot @member* close</code>
<ul>
<li>Alias for <code>rustbot @member* reversible close</code> - a reversible decision with
the proposed outcome <code>close</code>.</li>
</ul>
</li>
<li><code>rustbot @member* stabilize</code>
<ul>
<li>Alias for <code>rustbot @member* irreversible stabilize</code> - an irreversible
decision with the proposed outcome <code>stabilize</code>.</li>
</ul>
</li>
<li><code>rustbot @member* abstain</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set your status to <code>abstain</code>. This status does not
block a decision.</li>
</ul>
</li>
<li><code>rustbot @member* hold</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set your status to <code>hold</code>
<ul>
<li>Every N days while a hold persists, rustbot will ping all members who
have status <code>hold</code> (and potentially other involved team members as well)</li>
</ul>
</li>
</ul>
</li>
<li><code>rustbot @member* dissent</code>
<ul>
<li>Equivalent to <code>abstain</code>, except that it sets a status of <code>dissent</code>. This
status on one team member does not block a decision. A status of <code>dissent</code>
on two or more team members will block a decision.</li>
<li>Note that <code>dissent</code> should not be set when first raising a concern, only
after attempts to resolve the concern have been unsuccessful.</li>
</ul>
</li>
<li><code>rustbot restart</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set all members other than the one issuing the
command to have a blank status. Preserve the last set status of the person
issuing the <code>restart</code>.</li>
<li>Note: if the last set status of any team members were irreversible, the
decision will continue to be treated as irreversible until all such members
set an explicit status otherwise.</li>
</ul>
</li>
<li><code>rustbot cancel</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: cancel the decision period.</li>
<li>Note that if a subsequent decision is started in the same issue, rustbot
should link to the previous decision summary table.</li>
</ul>
</li>
</ul>
<h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<h2 id="why-can-members-override-other-members-positions"><a class="header" href="#why-can-members-override-other-members-positions">Why can members override other members positions?</a></h2>
<p>It's quite common to want to check boxes and similar on behalf of all the
people in a meeting. It's also annoying to have to restart a decision process
(e.g. closing and reopening with rfcbot) just to be able to close concerns on
someone else's behalf (e.g. people who have left the team, or people who raised
a concern on behalf of someone else not on the team, or similar). We can trust
each other on the team. If people abuse <code>rustbot</code> to disrupt the process, that
isn't a problem to be solved with tooling.</p>
<h2 id="do-we-want-to-require-all-but-n-people-to-affirm-a-decision-as-rfcbot-does"><a class="header" href="#do-we-want-to-require-all-but-n-people-to-affirm-a-decision-as-rfcbot-does">Do we want to require &quot;all but N&quot; people to affirm a decision, as <code>rfcbot</code> does?</a></h2>
<p>We opted to require 100% participation on irreversible decisions such as
stabilization, but not on very lightweight reversible decisions such as
starting an initiative. We believe that lang team members can be expected to at
least leave a comment (even if just <code>rustbot abstain</code>), but in the limit we
also have the option to set a status on another member's behalf.</p>
<h2 id="why-does-the-timer-start-when-the-decision-period-starts-and-not-when-a-consensus-is-reached"><a class="header" href="#why-does-the-timer-start-when-the-decision-period-starts-and-not-when-a-consensus-is-reached">Why does the timer start when the decision period <em>starts</em>, and not when a consensus is reached?</a></h2>
<p>The current <code>rfcbot</code> starts the 10 day FCP timer once a consensus is reached.
However, we have observed that, in practice, the &quot;holdouts&quot; on consensus are
typically the lang team members. Further, this seems to assume a &quot;two-phased&quot;
decision making model where folks outside the team are commenting only after
the lang team has reached a consensus. In practice, both decision-making and
commenting tend to be more fluid, and hence we would prefer not to have a long
delay after we reach consensus.</p>
<h2 id="why-not-use-checkboxes"><a class="header" href="#why-not-use-checkboxes">Why not use checkboxes?</a></h2>
<p>This process recognizes that sometimes, in the flow of conversation, the
decision to merge can transmute into a decision to close, or there may be
multiple potential outcomes.</p>
<p>The presentation of statuses also makes it easy for <code>rustbot</code> to present the
history of status changes, with links to team members' messages.</p>
<h2 id="why-is-close-always-reversible"><a class="header" href="#why-is-close-always-reversible">Why is <code>close</code> always reversible?</a></h2>
<p>Because, well, it is! We can always re-open a PR or issue, after all.</p>
<h2 id="what-about-postpone"><a class="header" href="#what-about-postpone">What about &quot;postpone&quot;?</a></h2>
<p>Just write it in the comment for a <code>@rustbot close</code>. In practice, a &quot;close&quot;
does not preclude reopening later, and a &quot;postpone&quot; does not guarantee
reopening later.</p>
<h2 id="is-dont-force-an-irreversible-decision-absolute"><a class="header" href="#is-dont-force-an-irreversible-decision-absolute">Is &quot;Don't force an irreversible decision?&quot; absolute?</a></h2>
<p>No; it's a strongly held principle, but not an absolute one. Sometimes we may
have to make an irreversible decision, even in the face of dissent. However, we
should be <em>extraordinarily</em> careful when doing so, and in particular, we should
consider very carefully whether we could make a reversible decision, or find a
better consensus, or whether the consequences of <em>not</em> making the decision
outweigh the consequences of making it. This should be an extremely rare event.</p>
<p>The previous decision-making process based on <code>rfcbot</code> allowed indefinitely
blocking concerns. This new process introduces a means of carefully resolving
such concerns, and a very careful means of proceeding <em>despite</em> such concerns
while ensuring those concerns are understood and recorded and considered.</p>
<h2 id="what-purpose-does-restart-serve"><a class="header" href="#what-purpose-does-restart-serve">What purpose does <code>restart</code> serve?</a></h2>
<p>Sometimes, a proposal has changed enough to warrant re-checking people's
positions, but has not changed enough to warrant closing it and starting the
process over. <code>restart</code> clears people's statuses to ensure that they have the
opportunity to re-confirm (or raise a hold or concern) before the decision
proceeds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lang-team-how-to-guide"><a class="header" href="#lang-team-how-to-guide">Lang team &quot;how to&quot; guide</a></h1>
<p>This section includes instructions on how to do various interactions with the lang team.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nominate-an-issue"><a class="header" href="#nominate-an-issue">Nominate an issue</a></h1>
<ul>
<li>Nomination is currently supported on the following repositories:
<ul>
<li>rust-lang/rfcs</li>
<li>rust-lang/rust</li>
<li>rust-lang/reference</li>
<li>rust-lang/lang-team</li>
<li>(this set is defined by the <code>nominated</code> list in the <a href="https://github.com/rust-lang/triagebot/blob/master/src/agenda.rs">triagebot source code</a>)</li>
</ul>
</li>
<li>Tag the issue with the <code>I-nominated</code> and <code>T-lang</code> labels by issuing the following <a href="https://github.com/rust-lang/triagebot/wiki">rustbot</a> command:
<ul>
<li><code>@rustbot label +I-nominate +T-lang</code></li>
</ul>
</li>
<li>Add a comment explaining
<ul>
<li>What question you would like answered by the lang team</li>
<li>Relevant background info or links to relevant info that the lang team can use to get &quot;oriented&quot; in the discussion</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propose-an-initiative"><a class="header" href="#propose-an-initiative">Propose an initiative</a></h1>
<p>See the <a href="how_to/../initiatives/process.html">initiative process</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proposing-a-topic-for-a-design-meeting"><a class="header" href="#proposing-a-topic-for-a-design-meeting">Proposing a topic for a design meeting</a></h1>
<p>You can propose a topic for a design meeting by opening an <a href="https://github.com/rust-lang/lang-team/issues/new/choose">Design
meeting proposal</a> issue on the lang-team repository. We schedule meetings in our monthly
planning meeting.</p>
<p>Every design meeting begins by reading a document and leaving comments. That document
must be prepared 24 hours in advance of the design meeting and posted on the issue.
If you propose an issue, you should be willing to prepare that document, or else indicate
who will do the preparation.</p>
<p>Typically, design meetings are associated with active initiatives: you may wish to
<a href="how_to/./propose.html">propose an initiative</a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat-platform"><a class="header" href="#chat-platform">Chat platform</a></h1>
<p>The lang team hangs out in the <a href="https://forge.rust-lang.org/chat/zulip.html">rust-lang Zulip</a> in the <code>#t-lang</code>
stream. There are also other <code>#t-lang/*</code> streams that might be of
interest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calendar"><a class="header" href="#calendar">Calendar</a></h1>
<p>We have a lang-team calendar that shows the time for our various meetings.
Meetings are generally open to anyone who wants to listen in. We also try to
post <a href="https://github.com/rust-lang/lang-team/tree/master/minutes">minutes</a> (and recordings, if any) on a &quot;best-effort&quot; basis from our
meetings.</p>
<ul>
<li><a href="https://calendar.google.com/calendar/embed?src=recud4b9o8cmc0m5rmr033p5nk%40group.calendar.google.com">View calendar</a> -- use this to view the calendar online and add it to your Google Calendar</li>
<li><a href="https://calendar.google.com/calendar/ical/recud4b9o8cmc0m5rmr033p5nk%40group.calendar.google.com/public/basic.ics">ICS file, for use outside from google calendar</a> -- you can use this to subscribe from other programs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meetings"><a class="header" href="#meetings">Meetings</a></h1>
<p>The lang team has several kinds of standing meetings.</p>
<ul>
<li><a href="./meetings/triage.html">Triage meetings</a></li>
<li><a href="./meetings/design.html">Design and planning meetings</a></li>
<li><a href="./meetings/backlog-bonanza.html">Backlog bonanza</a></li>
</ul>
<p>Unless otherwise noted, all of our meetings are open to the public for anyone to attend. You will find the timing and event details on our <a href="./calendar.html">lang team calendar</a>. We publish notes and minutes in written form in this github repository.</p>
<h2 id="recording-policy"><a class="header" href="#recording-policy">Recording policy</a></h2>
<p>Dy default, our triage and design meetings are <strong>not recorded</strong>, in order to encourage engagement from a broad audience. We may record certain design meetings, evaluated on a case-by-case basis, and only with the agreement of all participants. Any intention to record a design meeting will be established at that time that meeting is scheduled during the monthly planning meeting and included in the blog post announcing the upcoming meetings.</p>
<p>Our <a href="https://www.youtube.com/playlist?list=PL85XCvVPmGQg-gYy7R6a_Y91oQLdsbSpa">YouTube playlist</a> has recordings of some of our past meetings (along with automatically created subtitles).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triage-meeting"><a class="header" href="#triage-meeting">Triage meeting</a></h1>
<p>The weekly triage meeting is when we go over the newly filed project
proposals along with issues that have been nominated for lang-team
feedback. We also get regular updates from the active project groups
so we can stay on top of what is going on.</p>
<h2 id="can-i-attend"><a class="header" href="#can-i-attend">Can I attend?</a></h2>
<p>Yes! The triage meeting is open to the public. You'll find the details
on our <a href="meetings/src/../../calendar.html">calendar</a>.</p>
<h2 id="how-do-i-get-something-on-the-agenda"><a class="header" href="#how-do-i-get-something-on-the-agenda">How do I get something on the agenda?</a></h2>
<p>The easiest way to get something on the agenda is to <a href="meetings/../how_to/nominate.html">nominate it</a>. The agenda is automatically built by triagebot from <a href="https://github.com/rust-lang/triagebot/blob/master/templates/lang_agenda.tt">this template</a>. We review pending <a href="meetings/../how_to/propose.html">initiative proposals</a>, <a href="meetings/../how_to/nominate.html">nominated</a> issues and PRs from a variety of repositories, as well as pending RFC requests.</p>
<h2 id="can-i-generate-the-agenda-myself"><a class="header" href="#can-i-generate-the-agenda-myself">Can I generate the agenda myself?</a></h2>
<p>Sure. You can visit the following link and one will be generated for you for (the current date):</p>
<p>https://triage.rust-lang.org/agenda/lang/triage</p>
<p>Alternatively, clone the <a href="https://github.com/rust-lang/triagebot">triagebot</a> repo and run this</p>
<pre><code class="language-bash">&gt; cargo run --bin lang agenda
</code></pre>
<p>If you install the <code>hackmd-cli</code>, you can do this:</p>
<pre><code class="language-bash">cargo run --bin lang agenda | hackmd-cli import 
</code></pre>
<h2 id="where-can-i-find-the-minutes"><a class="header" href="#where-can-i-find-the-minutes">Where can I find the minutes?</a></h2>
<p><a href="https://github.com/rust-lang/lang-team/tree/master/minutes">Triage meeting minutes are available in this directory.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-meetings"><a class="header" href="#design-meetings">Design meetings</a></h1>
<p>We reserve a weekly slot for our planning and design meetings. 
A <strong>design meeting</strong> is a one-hour deep-dive discussion into some particular
topic. Each meeting is centered around a document that is prepared for
that meeting explaining the details of what is to be discussed; we begin by reading
the document and then discussing its contents. These meetings are used for all kinds
of purposes, such as brainstorming, getting feedback on an idea, or building
consensus around a specific proposals.</p>
<h2 id="how-are-design-meetings-scheduled"><a class="header" href="#how-are-design-meetings-scheduled">How are design meetings scheduled?</a></h2>
<p>To schedule design meetings, we hold a special <strong>planning meeeting</strong> once per month.
In that meeting, we choose what design meetings we will hold the rest of the month.</p>
<p>To generate the agenda for the planning meeting, you can use the following link and then copy/paste the generated text into a fresh hackmd page:</p>
<p>https://triage.rust-lang.org/agenda/lang/planning</p>
<h2 id="how-do-i-propose-a-design-meeting"><a class="header" href="#how-do-i-propose-a-design-meeting">How do I propose a design meeting?</a></h2>
<p>You need to open an issue, <a href="meetings/../how_to/design_meeting.html">as described here</a>.</p>
<h2 id="can-i-attend-1"><a class="header" href="#can-i-attend-1">Can I attend?</a></h2>
<p>Yes! Design meetings are open to the public. You'll find the details on our <a href="meetings/../calendar.html">calendar</a>.</p>
<h2 id="how-does-a-design-meeting-work"><a class="header" href="#how-does-a-design-meeting-work">How does a design meeting work?</a></h2>
<p>Before the meeting starts, someone has to prepare a document -- we recommend using hackmd and using <a href="https://hackmd.io/VJrbVMeqT4uUDBRVncHyTw">this template</a>. </p>
<p>When the meeting starts, send out the link to your document on Zulip (and on Zoom, if you like). Everyone will start to read it. <strong>There is no expectation that people will read the document in advance.</strong></p>
<p>As they read, people will append questions to the end of the document -- the template has a space for this. We recommend making each question into a markdown section (e.g., <code>### Why is this document so great?</code>). People will append their question in that section.</p>
<p>After everyone is done reading, whoever is driving the meeting will pick questions to discuss. Typically we go in linear order but that's not required, we can go in whatever order seems best.</p>
<h2 id="where-can-i-find-the-minutes-1"><a class="header" href="#where-can-i-find-the-minutes-1">Where can I find the minutes?</a></h2>
<p>The <a href="https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes">design-meeting-minutes directory</a> contains the document from each meeting along with any questions that were asked and the ensuing disceussion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backlog-bonanza"><a class="header" href="#backlog-bonanza">Backlog bonanza</a></h1>
<p>Backlog bonanza is a particular kind of design meeting. We often schedule a backlog bonanza for those weeks where we don't have more specific things to discuss. The idea is to go through each tracking issue and &quot;disposition them&quot;. The goal is to identify what we ought to do with this particular unstable feature; e.g., what is blocking this from being stabilized? Do we still want this? Is it perma-unstable?</p>
<h2 id="when-does-backlog-bonanza-take-place"><a class="header" href="#when-does-backlog-bonanza-take-place">When does backlog bonanza take place?</a></h2>
<p>Backlog bonanza meetings are typically scheduled as <a href="meetings/design.html">design meetings</a>.</p>
<h2 id="can-i-attend-2"><a class="header" href="#can-i-attend-2">Can I attend?</a></h2>
<p>Yes! Design meetings are open to the public. You'll find the details on our <a href="meetings/../calendar.html">calendar</a>.</p>
<h2 id="what-labels-do-we-apply-to-issues"><a class="header" href="#what-labels-do-we-apply-to-issues">What labels do we apply to issues?</a></h2>
<p>Here are the labels we apply during the process and their meaning:</p>
<ul>
<li>S-tracking-ready-to-stabilize: Needs a stabilization PR (good to go :train:)</li>
<li>S-tracking-needs-to-bake: Needs time to bake (set a date? other criteria?)</li>
<li>S-tracking-impl-incomplete: Not code complete or blocking bugs</li>
<li>S-tracking-unimplemented: Implementation not begun</li>
<li>S-tracking-design-concerns: Blocking design concerns
<ul>
<li>This might be &quot;doesn't quite seem to deliver value we hoped for&quot; or &quot;something doesn't feel right&quot;</li>
</ul>
</li>
<li>S-tracking-perma-unstable
<ul>
<li>Internal implementation detail of rustc, stdlib</li>
</ul>
</li>
<li>S-tracking-needs-investigation</li>
</ul>
<h2 id="where-can-i-find-the-minutes-2"><a class="header" href="#where-can-i-find-the-minutes-2">Where can I find the minutes?</a></h2>
<p>Currently the minutes are tracked in the issues themselves, but we also create hackmd documents in the <a href="https://hackmd.io/team/rust-lang-team?nav=overview">Rust lang team</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section contains &quot;notes&quot; about the design of various proposals.
These are often just links to conversations, along with a few key
ideas and summaries. Sometimes it includes other information, such as
lang-team decisions about whether a particular proposal is viable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="can-we-allow-integer-literals-like-1-to-be-inferred-to-floating-point-type"><a class="header" href="#can-we-allow-integer-literals-like-1-to-be-inferred-to-floating-point-type">Can we allow integer literals like <code>1</code> to be inferred to floating point type?</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>In rust today, an integer like <code>1</code> cannot be inferred to floating
point type. This means that valid-looking numeric expressions like
<code>22.5 + 1</code> will not compile, and one must instead write <code>22.5 + 1.0</code>. Can/should we change this?</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>This was discussed on Zulip in <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html">May 2020</a>. Some of the key highlights from the discussion were:</p>
<ul>
<li>Floating point literals are prone to many surprises that integers
are not. For <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196887384">example</a>, <code>20_000_000 + 1</code>, if inferred to <code>f32</code>
type, would have the final value <code>20_000_000.0</code>. This leads some to
conclude that <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196887384">&quot;the surprise factor of floats is so high that they
are qualitatively different than integers&quot;</a>.</li>
<li>But there are a lot of similar surprising things:
<ul>
<li><a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196930252"><code>20_000_001_f32</code>, for example, is also going to be <code>20_000_000</code>.</a></li>
<li>Integer overflow can mean that <code>255 + 1</code> has the value 0.</li>
</ul>
</li>
<li>Some key questions to consider:
<ul>
<li><a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196926142">How often does adding <code>.0</code> result in some insight?</a></li>
<li>How much would <em>seeing</em> the <code>.0</code> help to debug a tricky problem?</li>
</ul>
</li>
<li>Balanced against the annoyance and surprise factor.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalized-coroutines"><a class="header" href="#generalized-coroutines">Generalized coroutines</a></h1>
<p>Since even before Rust 1.0, users have desired the ability to <code>yield</code> like in
other languages. The compiler infrastructure to achieve this, along with an
unstable syntax, have existed for a while now. But despite <em>a lot</em> of debate,
we've failed to polish the feature up enough to stabilize it. I've tried to
write up a summary of the different design considerations and the past debate
around them below:</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li>The distinction between a &quot;coroutine&quot; and a &quot;generator&quot; can be a bit vague,
varying from one discussion to the next.</li>
<li>In these notes a generator is anything which <em>directly</em> implements <code>Iterator</code>
or <code>Stream</code> while a coroutine is anything which can take arbitrary input,
yield arbitrary output, and later resume execution at the previous yield.</li>
<li>Thus, the &quot;generator&quot; syntax proposed in <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> and currently
implemented behind the &quot;generator&quot; feature is actually a coroutine syntax for
the sake of these notes, <em>not a true generator</em>.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> defines a true generator syntax in &quot;future additions&quot;.</li>
</ul>
</li>
<li>Note also that &quot;coroutines&quot; here are really &quot;semicoroutines&quot; since they can
only yield back to their caller.</li>
<li>I will continue to group the <a href="https://github.com/rust-lang/rfcs/pull/2033">original eRFC text</a> and the later <a href="https://github.com/rust-lang/rust/pull/68524">generator
resume arguments</a> extension
togther as &quot;<a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a>&quot;. That way I only have 3 big proposals to deal
with.</li>
<li>In rustc, a coroutine's &quot;witness&quot; is the space where stack-allocated values
are stored if needed across yields. I'm borrowing this terminology here. Any
such cross-yield bindings are said to be &quot;witnessed&quot;.</li>
</ul>
<pre><code class="language-rust ignore">// This is an example coroutine which might assist a streaming base64 encoder
|sextet, octets| {
    let a = sextet; // witness a, b, and c sextets for later use
    yield;
    let b = sextet;
    octets.push(a &lt;&lt; 2 | b &gt;&gt; 4); // aaaaaabb
    yield;
    let c = sextet;
    octets.push((b &amp; 0b1111) &lt;&lt; 4 | c &gt;&gt; 2); // bbbbcccc
    yield;
    octets.push((c &amp; 0b11) &lt;&lt; 6 | sextet) // ccdddddd
}

// This is an example generator which might be used in Iterator::flat_map.
gen {
  for item in inner {
    for mapped in func(item) {
      yield mapped;
    }
  }
}

// This is an example async generator which might be used in Stream::and_then
async gen {
  while let Some(item) = inner.next().await {
    yield func(item).await;
  }
}
</code></pre>
<h2 id="coroutine-trait"><a class="header" href="#coroutine-trait">Coroutine trait</a></h2>
<ul>
<li>The coroutine syntax must produce implementations of some trait.</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose the <code>Generator</code> trait.</li>
<li>Note that Rust's coroutines and subroutines look the same from the outside:
take input, mutate state, produce output.</li>
<li>Thus, <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> proposes using the <code>Fn*</code> traits instead, including a new
<code>FnPin</code> for immovable coroutines.
<ul>
<li>Hierarchy: <code>Fn</code> is <code>FnMut + Unpin</code> is <code>FnPin</code> is <code>FnOnce</code>.
<ul>
<li>May not be <em>required</em> at the trait level (someone may someday find a use
to implementing <code>FnMut + !FnPin</code>) but all closures implement the traits in
this order.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="coroutine-syntax"><a class="header" href="#coroutine-syntax">Coroutine syntax</a></h2>
<ul>
<li>The closure syntax is reused for coroutines by <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a>, <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a>,
and <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>.</li>
<li>Commentators have suggested that the differences between coroutines and
closures under <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> and <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> justify an entirely distinct
syntax to reduce confusion.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> fully reuses the <em>semantics</em> of closures, greatly simplifying the
design space and making the shared syntax obvious.</li>
</ul>
<h2 id="taking-input"><a class="header" href="#taking-input">Taking input</a></h2>
<ul>
<li>The major disagreement between past proposals is whether to use &quot;yield
expressions&quot; or &quot;magic mutation&quot;.
<ul>
<li>Yield expression: <code>let after = yield output;</code>
<ul>
<li>Used by <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a></li>
</ul>
</li>
<li>Magic mutation: <code>let before = arg; yield output; let after = arg;</code>
<ul>
<li>Used by <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a></li>
</ul>
</li>
</ul>
</li>
<li>Many people have a strong gut preference for yield expressions.
<ul>
<li>In simple cases, Rust generally prefers to produce values as output from
expressions rather than by mutation of state. &quot;Yield expressions <em>feel</em> more
Rusty.&quot;</li>
<li>However, magic mutation is likely correct, even though at first glance it
feels surprising. In addition to reasons below, holding references to past
resume args is rare, often a logic error. Rust can use mutation checks to
catch and give feedback.</li>
</ul>
</li>
<li>&quot;Magic mutation&quot; is a bit of a misnomer. The resume argument values are <em>not
themselves being mutated.</em> The argument bindings are simply being reassigned
across yields.
<ul>
<li>In a sense, argument bindings are reassigned in the exact same way across
returns.</li>
<li>Previous arguments (if unmoved) are dropped prior to yielding and are
reassigned after resuming.</li>
<li>People will get yelled at by the borrow checker if they try to hold borrows
of arguments across yields. But the fix is generally easy: move the argument
to a new binding before yielding.</li>
</ul>
</li>
</ul>
<pre><code class="language-text">=&gt; |x| {
    let y = &amp;x;
    yield;
    dbg!(y, x);
}

error[E0506]: cannot pass new `x` because it is borrowed
 --&gt; src/lib.rs:3:4
  |
2 |     let y = &amp;x;
  |             -- borrow of `x` occurs here
3 |     yield;
  |     ^^^^^ assignment to borrowed `x` occurs here
4 |     dbg!(y, x);
  |             - borrow later used here
  |
  = help: consider moving `x` into a new binding before borrowing

=&gt; |x| {
    let a = x;
    let y = &amp;a;
    yield;
    dbg!(y, x);
}
</code></pre>
<ul>
<li>Magic mutation could be replaced by &quot;magic shadowing&quot; where new arguments
shadow old ones at yield in order to allow easy borrowing of past argument
values. But this is a huge footgun. See if you can spot the issue with the
following code if <code>ctx</code> shadows its past value rather than overwriting it:</li>
</ul>
<pre><code class="language-rust ignore">std::future::from_fn(|ctx| {
  if is_blocked() {
    register_waker(ctx);
    yield Pending;
  }

  while let Pending = task.poll(ctx) { .. }
})
</code></pre>
<ul>
<li>&quot;Yield expression&quot; causes problems with first-resume input.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> passes the first resume argument via a closure parameters
while later arguments are produced by <code>yield</code> expressions.</li>
<li>This part of why it is so hard to unify generalized coroutines with a
generator syntax like <code>gen { }</code> or <code>gen fn</code>. Where does the first input go?
Where do you annotate the argument type even?</li>
</ul>
</li>
<li>To increase clarity, users almost always want resume arguments to be named.
<ul>
<li>With magic mutation, all resume arguments are already named since they reuse
the closures arguments on every resume. Any unmoved arguments are dropped
just prior to yielding, so they are not witnessed and do not increase the
coroutine size.
<ul>
<li>Also get multiple arguments for free if using the <code>Fn*</code> traits.</li>
</ul>
</li>
<li>Yield expressions require users to repeatedly assign resume arguments to
named bindings manually. Such bindings must be included in the closure state
if they have any drop logic.</li>
</ul>
</li>
</ul>
<h2 id="borrowed-resume-arguments"><a class="header" href="#borrowed-resume-arguments">Borrowed resume arguments</a></h2>
<ul>
<li>What happens when a coroutine witnesses a borrow passed as a resume argument?
For example:</li>
</ul>
<pre><code class="language-rust ignore">let co = |x: &amp;i32| {
  let mut values = Vec::new();
  loop {
    values.push(x);
    yield;
  }
};

// potentially ok:
let mut x = 0;
co(&amp;x);

// must not be allowed:
x = 1;
co(&amp;x);
</code></pre>
<ul>
<li>As of writing, <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> leaves this as an unresolved question with a note
to potentially restrict resume arguments to being <code>'static</code>.</li>
<li>Since coroutines under <a href="https://github.com/rust-lang/rfcs/pull/2781">MCP-49</a> act as much like closures as possible, and
treat the witness and capture data the same whenever possible, the example
above would fail in a similar way to the example below, giving a &quot;borrowed
data escapes into closure state&quot; error or similar even if <code>x</code> is not mutated.</li>
</ul>
<pre><code class="language-rust ignore">let mut values = Vec::new();
|x: &amp;i32| {
  loop {
    values.push(x);
//  ^^^^^^^^^^^^^^ `x` escapes the closure body here
    yield;
  }
}
</code></pre>
<ul>
<li>As of writing, <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> appears to take a similar approach (although the
error message is not super descriptive).</li>
<li>Ideally someday we'd do something nicer but any such solution would apply to both captured state and witnessed state in the same way.</li>
</ul>
<h2 id="lending"><a class="header" href="#lending">Lending</a></h2>
<ul>
<li>Coroutines would eventually like to yield borrows of state to the caller. This
is &quot;lending&quot; coroutine (sometimes also called an &quot;attached&quot; coroutine).</li>
<li>Using <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>, a lending coroutine might look like:</li>
</ul>
<pre><code class="language-rust ignore">|| {
  let mut buffer = Vec::new();
  loop {
    let n = fill_buffer(&amp;mut buffer);
    yield &amp;buffer[..n];
  }
}
</code></pre>
<ul>
<li>None of the major proposals have made an effort to resolve this directly as
far as I am aware.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> gets the closest with a mention of <code>LendingStream</code> and
<code>LendingIterator</code> traits in &quot;future additions&quot;.</li>
<li>We should probably get some experience with lending traits at the lib level
before attempting to add language level support.</li>
</ul>
</li>
<li>If lending closures were implemented, <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> could immediately be used to
build lending streams, iterators, etc so long as the respective traits have
the needed GAT-ification.</li>
</ul>
<h2 id="enum-wrapping"><a class="header" href="#enum-wrapping">Enum-wrapping</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose that <code>yield x</code> should produce
<code>GeneratorState::Yielded(x)</code> or equivalent as an output, in order to
discriminate between yielded and returned values.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> instead gives <code>yield x</code> and <code>return x</code> nearly identical semantics
and output <code>x</code> directly, so the two must return the same type.</li>
<li>Enum-wrapping here is analogous to Ok-wrapping elsewhere. Similar debates
result.</li>
<li>When using enum-wrapping, the syntax to specify distinct return/yield types is
hotly debated.</li>
<li>Generators always want return and yield to have different types (<code>()</code> vs <code>T</code>)
but a generator syntax on top of coroutines could be used to auto-insert enum
wrappers around yield vs return arguments.</li>
<li>Auto-enum-wrapping can slightly improve type safety in some cases where
<code>return</code> should be treated specially to avoid bugs.</li>
<li>No-enum-wrapping when combined with the <code>impl Fn*</code> choice of trait, allow
the coroutine syntax to be used directly with existing higher-order methods
on iterator, stream, collection types, async traits, etc.</li>
<li>Note these two approaches are &quot;isomorphic&quot;: a coroutine that returns
<code>GeneratorState&lt;T, T&gt;</code> could be wrapped to return <code>T</code> by some sort of
combinator and a coroutine that only returns <code>T</code> can have <code>yield</code> and <code>return</code>
values manually wrapped in <code>GeneratorState</code>. This is just about ergonomics:</li>
</ul>
<pre><code class="language-rust ignore">// Without enum wrapping:
std::iter::from_fn(|| {
  yield Some(1);
  yield Some(2);
  yield Some(3);
  None
}).map(|x| {
  yield -x;
  yield x;
});

// With enum wrapping:
std::iter::from_gen_fn(|| {
  yield 1;
  yield 2;
  yield 3;
}).map(unwrap_gen_state(|x| {
  yield -x;
  yield x;
}));

// Needed for un-enum-wrapping when not desired.
// Could be replaced by sufficiently fancy !-casting?
fn unwrap_gen_state&lt;T&gt;(f: impl FnMut() -&gt; GeneratorState&lt;T, !&gt;) -&gt; T { ... }
fn merge_gen_state&lt;T&gt;(f: impl FnMut() -&gt; GeneratorState&lt;T, T&gt;) -&gt; T { ... }

// With no wrapping + generators:
(gen {
  yield 1;
  yield 2;
  yield 3;
}).map(|x| {
  yield -x;
  yield x;
})
</code></pre>
<h2 id="movability"><a class="header" href="#movability">Movability</a></h2>
<ul>
<li>All proposals want movability/<code>impl Unpin</code> to be inferred.
<ul>
<li>If we forbid &quot;borrowed data escaping into closure state&quot;, the inference
rules should be relatively simple: witnessing any borrow triggers
immovability.
<ul>
<li>Dead borrows should not be witnessed.</li>
</ul>
</li>
<li>But exact inference rules may only be well understood after an attempt at
implementation.</li>
</ul>
</li>
<li>Soundness of <code>pin_mut!</code> is a little tricky but seems to be fine no matter what.
<ul>
<li>If the resulting mutable borrow is witnessed ⇒ coroutine is <code>!Unpin</code> because
of inference rules</li>
<li>If the pinned data is <code>!Unpin</code> and is witnessed ⇒ coroutine is <code>!Unpin</code>
because witness contains <code>!Unpin</code> data</li>
<li>Thus, if the coroutine can be moved after resume, any data stack-pinned
(really witness-pinned) by <code>pin_mut!</code> is not referenced and is <code>Unpin</code>.</li>
</ul>
</li>
<li>Until inference is solved, the <code>static</code> keyword can be used as a modifier.</li>
</ul>
<pre><code class="language-rust ignore">// movable via inference
|| {
  let x = 4;
  let y = &amp;x;
  dbg!(y);
  yield;
}

// guaranteed movable (pending inference)
static || {
  ...
}

// immovable
|| {
  let x = 4;
  let y = &amp;x;
  yield;
  dbg!(y);
}
</code></pre>
<h2 id="once-coroutines"><a class="header" href="#once-coroutines">&quot;Once&quot; coroutines</a></h2>
<ul>
<li>A lot of coroutines destroy captured data when run.</li>
<li>These coroutines (notably futures) can be resumed many times but can only be
run through &quot;once&quot;.</li>
<li>In contrast to non-yield <code>FnOnce</code> closures, this can not be solved at the type
level because a coroutine can run out after an arbitrary, runtime-dependent
number of resumptions.
<ul>
<li>Attempts to discriminate with enums tend to run up against <code>Pin</code>.</li>
</ul>
</li>
<li>Coroutines must have the ability to block restart with a <code>panic!</code>.
<ul>
<li>Following <code>return</code>.</li>
<li>Following <code>panic!</code> and recovery.</li>
<li>The term &quot;poison state&quot; technically refers to only the later case. But here
I will use it to mean any state at which the closure panics if resumed.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose that all coroutines become poisoned
after returning.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> recommends that all non-capture-destroying coroutines resume at
their initial state after returning.
<ul>
<li>This can be very handy in some situations. In fact, I use it several times
in examples to increase readability. See anywhere I <code>iter.map(coroutine)</code> or
the base64 encoder.</li>
<li>Similar question around generators: should they loop to save on a state or
should they be fused-by-default?</li>
<li>If we do decide to panic-after-return, restart-after-return can still be
emulated using <code>loop { .. }</code> as the coroutine body instead of simply <code>{ .. }</code>. This is even zero-cost because unreachable poison states are eliminated.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> also optionally proposes that capture-destroying closures should
only implement <code>FnOnce</code> unless explicitly annotated, even if they should
apparently be resumable several times.
<ul>
<li><code>mut || { drop(capture); }</code> is recommended as the modifier, to hint that an
<code>FnMut</code> impl is being requested when the closure in question would otherwise
impl only <code>FnOnce</code>.</li>
<li>But the behavior of this modifier is probably too obscure and requires
too much explanation vs &quot;closures always impl FnMut/FnPin if they contain
yield&quot;.</li>
</ul>
</li>
</ul>
<h2 id="async-coroutines"><a class="header" href="#async-coroutines">Async coroutines</a></h2>
<ul>
<li>I am aware of no strong proposal for an async version of generalized
coroutines although a fair amount of discussion has taken place.
<ul>
<li>In the context of <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>, how should <code>async || { ... yield ...}</code> be
handled in the very long-term? <em>Error right now.</em></li>
</ul>
</li>
<li>Async coroutines don't make much sense because of resume arguments. Async
functions are already coroutines which take an <code>&amp;mut Context</code> as a resume
argument. How should additional arguments should be specified?
<ul>
<li>Do the additional args need to be passed every single poll or are they only
needed when resuming after <code>Ready</code>?</li>
<li>If they are stored between <code>Ready</code>s, how does that interact with the ban on
witnessing external borrows? Badly.</li>
<li>On resume, the the coroutine might only take the additional arguments. It
could then yield a future to take the async context and handle any <code>Pending</code>
yields.</li>
<li>If so, how is the coroutine body broken up into distinct futures to be
yielded?</li>
<li>What happens if a yielded future is destroyed early? Panic on resume?</li>
</ul>
</li>
<li>Generators and async are both sugars on top of coroutines and are orthogonal
to each other. But neither is orthogonal to the underlying coroutine feature:</li>
</ul>
<pre><code class="language-rust ignore">// an async block
async {
  &quot;hello&quot;
}

// an async generator
async gen {
  yield &quot;hello&quot;;
}

// an &quot;async coroutine&quot;
|ctx: &amp;mut Context| {
  yield Poll::Ready(&quot;hello&quot;);
}
</code></pre>
<ul>
<li>Taking the async context explicitly makes it cleaner to implement some complex
async functions which take additional poll parameters.
<ul>
<li>An <code>await_with!</code> macro would be quite useful for implementing <code>await</code> loops
on arbitrary <code>Poll</code>-returning functions.
<ul>
<li>Would be a good candidate for an <code>.await(args..)</code> syntax if very heavily
used.</li>
</ul>
</li>
<li>For example, an simple little checksumming async write wrapper might look
like this:</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore">|ctx: &amp;mut Context, bytes: &amp;[u8]| -&gt; Poll&lt;usize&gt; {
  let mut checksum = 0;
  let mut count = 0;
  pin_mut!(writer);

  loop {
    let n = 4096 - count;
    if n == 0 {
      await_with!(writer.poll_write, ctx, &amp;[checksum]);
    }

    let part = &amp;bytes[..bytes.len().min(n)];
    checksum = part.fold(checksum, |x, &amp;y| x ^ y);
    await_with!(writer.poll_write, ctx, part);

    count += part.len();
    yield Ready(part.len());
  }
}
</code></pre>
<h2 id="try"><a class="header" href="#try">Try</a></h2>
<ul>
<li>All proposals work fine with the <code>?</code> operator without even trying (haha).</li>
<li><code>Poll&lt;Result&lt;_, _&gt;&gt;</code> and <code>Poll&lt;Option&lt;Result&lt;_, _&gt;&gt;&gt;</code> already implement <code>Try</code>!</li>
<li>Generators usually want a totally different <code>?</code> desugar that does <code>yield Some(Err(...)); return None;</code> instead of <code>return Err(...)</code>.
<ul>
<li>This comes up a lot in discussions of general coroutine syntaxes but just
muddies things up because (say it with me) generators ≠ coroutines.</li>
<li>Sugar-free implementation is easy: <code>yield Some(try { ... }); None</code></li>
</ul>
</li>
<li>Try blocks in general are super useful for handing errors by moving into
specific error-handeling states.</li>
</ul>
<h2 id="language-similarity"><a class="header" href="#language-similarity">Language similarity</a></h2>
<ul>
<li>Rust's version of coroutines can be a bit unusual compared to other languages.
But the reason for this is simple: you need arguments to resume Rusty
coroutines.</li>
<li>Resume arguments in other languages can be passed just fine by sharing mutable
data. So all they need to implement are generators, not true coroutines as
defined here.</li>
</ul>
<pre><code class="language-python"># Generator function takes a word list and name on construction.
# The shared list is mutated to make room for new words.
def write_greeting(name, words):
    words.append('hello')
    if words.is_full:
        yield
    words.append(name)

</code></pre>
<pre><code class="language-rust ignore">// Function only needs name to construct coroutine.
// Coroutine gets mutable access to the word list each resume.
fn write_greeting(name: String) -&gt; impl FnMut(&amp;mut Vec&lt;String&gt;) {
  |words| {
    words.push(&quot;hello&quot;.to_string());
    if words.len() == words.capacity() {
      yield
    }
    words.push(name);
  }
}

</code></pre>
<h2 id="language-complexity"><a class="header" href="#language-complexity">Language complexity</a></h2>
<ul>
<li>The main selling point of <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> is that it avoids adding a whole new language feature with associated design questions. Instead, the common answer to questions regarding MCP-49 is that yield-closures simply do whatever closures do.
<ul>
<li>The syntax is the same.</li>
<li>Captures work the same way.</li>
<li>Arguments are passed the same way.</li>
<li>Return and yield both drop the latest arguments and then pop the call stack.</li>
<li>The only big difference is that once <code>yield</code> is involved, some variables get
stored in a witness struct rather than in the stack frame. Plus the need for
a poison state.</li>
</ul>
</li>
<li>In fact, <code>return</code> behaves exactly like a simultaneous <code>yield</code> + <code>break 'closure_body</code>.
<ul>
<li>In a sense, every closure already has a single yield point at which it
resumes after <code>return</code>.</li>
<li>A <code>yield</code> adds a second resume point: hence the need for a discriminant.</li>
</ul>
</li>
<li>Under that proposal, anywhere a closure can be used, a coroutine can too. And
vice versa.</li>
</ul>
<h2 id="generator-unification"><a class="header" href="#generator-unification">Generator unification</a></h2>
<ul>
<li>So far in this proposal, I've been very careful to distinguish generators (as
supported by the propane and async_stream crates, proposed by <a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a>,
etc) from the coroutines discussed here. They are treated as two separate
language features.</li>
<li>Does Rust have &quot;room&quot; for both stream syntax and a generator syntax? Would it
be better to find a single solution to both?</li>
<li>A single solution is difficult for a few reasons:
<ul>
<li>Taking resume arguments muddies the syntax. For example, what would be the
syntax for a generator function which takes an explicit resume argument?</li>
<li>The closure syntax works great for coroutines which implement <code>Fn*</code> a la
<a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>! But reusing that syntax to magically implement <code>Iterator</code> or
<code>Stream</code> would cause confusion.</li>
<li>On that note, generators <em>definitely</em> want to implement different traits vs
coroutines. <code>Iterator</code> and <code>Stream</code> rather than <code>Fn</code> or (ironically)
<code>Generator</code>.</li>
<li>As stated above, async coroutines don't make much sense: async interacts
poorly with resume arguments.</li>
<li>Async generators are super important, don't care about resume arguments.</li>
<li>As mentioned in the section on try, generators and coroutines generally want
different error handling. Or at lest, some more complex <code>?</code> desugar is not
so obvious for coroutines in general as it is for generators specifically.</li>
</ul>
</li>
<li>Once generalized coroutines are in place, a generator syntax like the one in
<a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> is a trivial sugar on top:</li>
</ul>
<pre><code class="language-rust ignore">gen {
  for item in inner {
    for mapped in func(item) {
      yield mapped;
    }
  }
}

// becomes

std::iter::from_fn(|| {
  for item in inner {
    for mapped in func(item) {
      yield Some(mapped);
    }
  }
  None
})
</code></pre>
<pre><code class="language-rust ignore">async gen {
  while let Some(item) = inner.next().await {
    yield func(item).await;
  }
}

// becomes

std::stream::from_fn(|ctx| {
  while let Some(item) = await_with!(inner.next(), ctx) {
    yield Ready(Some(await_with!(func(item), ctx)));
  }
  Ready(None)
})
</code></pre>
<ul>
<li>Proc-macro crates could provide very satisfactory <code>gen</code> and <code>gen_async</code> macros
until we are sure of the need to support such a sugar directly in language as
a keyword or in core as a first-party macro.</li>
</ul>
<h2 id="past-discussions"><a class="header" href="#past-discussions">Past discussions</a></h2>
<p>There are a <em>lot</em> of these. Dozens of internals threads, reddit posts, blog
posts, draft RFCs, pre RFCs, actual RFCs, who knows what in Zulip, and so on.
So this isn't remotely exhaustive:</p>
<ul>
<li>https://github.com/CAD97/rust-rfcs/pull/1</li>
<li>https://github.com/rust-lang/lang-team/issues/49</li>
<li>https://github.com/rust-lang/rfcs/pull/2033</li>
<li>https://github.com/rust-lang/rfcs/pull/2781</li>
<li>https://github.com/rust-lang/rust/issues/43122</li>
<li>https://github.com/rust-lang/rust/pull/68524</li>
<li>https://internals.rust-lang.org/t/crazy-idea-coroutine-closures/1576</li>
<li>https://internals.rust-lang.org/t/no-return-for-generators/11138</li>
<li>https://internals.rust-lang.org/t/syntax-for-generators-with-resume-arguments/11456</li>
<li>https://internals.rust-lang.org/t/trait-generator-vs-trait-fnpin/10411</li>
<li>https://reddit.com/r/rust/comments/dvd3az/generalizing_coroutines/</li>
<li>https://samsartor.com/coroutines-2</li>
<li>https://smallcultfollowing.com/babysteps/blog/2020/03/10/async-interview-7-withoutboats/#async-fn-are-implemented-using-a-more-general-generator-mechanism</li>
<li>https://users.rust-lang.org/t/coroutines-and-rust/9058</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-capabilities-of-compiler-generated-function-types"><a class="header" href="#extending-the-capabilities-of-compiler-generated-function-types">Extending the capabilities of compiler-generated function types</a></h1>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p>Both standalone functions and closures have unique compiler-generated types.
The rest of this document will refer to both categories as simply &quot;function
types&quot;, and will use the phrase &quot;function types without upvars&quot; to refer to
standalone functions <em>and</em> closures without upvars.</p>
<p>Today, these function types have a small set of capabilities, which are
exposed via trait implementations and implicit conversions.</p>
<ul>
<li>
<p>The <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code> traits are implemented based on the way
in which upvars are used.</p>
</li>
<li>
<p><code>Copy</code> and <code>Clone</code> traits are implemented when all upvars implement the
same trait (trivially true for function types without upvars).</p>
</li>
<li>
<p><code>auto</code> traits are implemented when all upvars implement the same trait.</p>
</li>
<li>
<p>Function types without upvars have an implicit conversion to the
corresponding <em>function pointer</em> type.</p>
</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>There are several cases where it is necessary to write a <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)">trampoline</a>. A trampoline
is a (usually short) generic function that is used to adapt another function
in some way.</p>
<p>Trampolines have the caveat that they must be standalone functions. They cannot
capture any environment, as it is often necessary to convert them into a
function pointer.</p>
<p>Trampolines are most commonly used by compilers themselves. For example, when a
<code>dyn Trait</code> method is called, the corresponding vtable pointer might refer
to a trampoline rather than the original method in order to first down-cast
the <code>self</code> type to a concrete type.</p>
<p>However, trampolines can also be useful in low-level code that needs to interface
with C libraries, or even in higher level libraries that can use trampolines in
order to simplify their public-facing API without incurring a performance
penalty.</p>
<p>By expanding the capabilities of compiler-generated function types it would
be possible to write trampolines using only safe code.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The goal of this design note is describe a range of techniques for implementing
<em>trampolines</em> (defined below) and some of the feedback regarding those solutions.
This design note does not intend to favor any specific solutions, just reflect past
discussions. The presence or absence of any particular feedback in this document
does not necessarily serve to favor or disfavor any particular solution.</p>
<h2 id="history-1"><a class="header" href="#history-1">History</a></h2>
<p>Several mechanisms have been proposed to allow trampolines to be written in safe
code. These have been discussed at length in the following places.</p>
<p>PR adding <code>Default</code> implementation to function types:</p>
<ul>
<li>https://github.com/rust-lang/rust/pull/77688</li>
</ul>
<p>Lang team triage meeting discussions:</p>
<ul>
<li>https://youtu.be/NDeAH3woda8?t=2224</li>
<li>https://youtu.be/64_cy5BayLo?t=2028</li>
<li>https://youtu.be/t3-tF6cRZWw?t=1186</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<h3 id="an-adaptor-which-prevents-unwinding-into-c-code"><a class="header" href="#an-adaptor-which-prevents-unwinding-into-c-code">An adaptor which prevents unwinding into C code</a></h3>
<p>In this example, we are building a crate which provies a safe wrapper around
an underlying C API. The C API contains at least one function which accepts
a function pointer to be used as a callback:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod c_api {
    extern {
        pub fn call_me_back(f: extern &quot;C&quot; fn());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We would like to allow users of our crate to safely use their own callbacks.
The problem is that if the callback panics, we would unwind into C code and this
would be undefined behaviour.</p>
<p>To avoid this, we would like to interpose between the user-provided callback and
the C API, by wrapping it in a call to <code>catch_unwind</code>. Unfortunately, the C API
offers no way to pass an additional &quot;custom data&quot; field that we could use to
store the original function pointer.</p>
<p>Instead, we could write a generic function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{panic, process};

pub fn call_me_back_safely&lt;F: Fn() + Default&gt;(_f: F) {
    extern &quot;C&quot; fn catch_unwind_wrapper&lt;F: Fn() + Default&gt;() {
        if panic::catch_unwind(|| {
            let f = F::default();
            f()
        }).is_err() {
            process::abort();
        }
    }
    unsafe {
        c_api::call_me_back(catch_unwind_wrapper::&lt;F&gt;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This compiles, and is intended to be used like so:</p>
<pre><pre class="playground"><code class="language-rust">fn my_callback() {
    println!(&quot;I was called!&quot;)
}

fn main() {
    call_me_back_safely(my_callback);
}
</code></pre></pre>
<p>However, this will fail to compile with the following error:</p>
<blockquote>
<p>error[E0277]: the trait bound <code>fn() {my_callback}: Default</code> is not satisfied</p>
</blockquote>
<h2 id="implementing-the-default-trait"><a class="header" href="#implementing-the-default-trait">Implementing the <code>Default</code> trait</a></h2>
<p>The solution initially proposed was to implement <code>Default</code> for function types
without upvars. Safe trampolines would be written like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one_adapter&lt;F: Fn(i32) + Default&gt;(arg: i32) {
    let f = F::default();
    f(arg + 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>Discussions of this design had a few central themes.</p>
<h3 id="when-should-default-be-implemented"><a class="header" href="#when-should-default-be-implemented">When should <code>Default</code> be implemented?</a></h3>
<p>Unlike <code>Clone</code>, it intuitively does not make sense for a closure to implement
<code>Default</code> just because its upvars are themselves <code>Default</code>. A closure like
the following might not expect to ever observe an ID of zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_thing() -&gt; impl FnOnce() {
    let id: i32 = generate_id();
    || {
      do_something_with_id(id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The closure may have certain pre-conditions on its upvars that are violated
by code using the <code>Default</code> implementation. That said, if a function type has
no upvars, then there are no pre-conditions to be violated.</p>
<p>The general consensus was that if function types are to implement <code>Default</code>,
it should only be for those without upvars.</p>
<p>However, this point was also used as an argument against implementing
<code>Default</code>: traits like <code>Clone</code> are implemented structurally based on the
upvars, whereas this would be a deviation from that norm.</p>
<h3 id="leaking-details--weakening-privacy-concerns"><a class="header" href="#leaking-details--weakening-privacy-concerns">Leaking details / weakening privacy concerns</a></h3>
<p>Anyone who can observe a function type, and can also make use of the <code>Default</code>
bound, would be able to safely call that function. The concern is that this
may go against the intention of the function author, who did not explicitly
opt-in to the <code>Default</code> trait implementation for their function type.</p>
<p>Points against this argument:</p>
<ul>
<li>
<p>We already leak this kind of capability with the <code>Clone</code> trait implementation.
A function author may write a <code>FnOnce</code> closure and rely on it only being callable once. However, if the upvars are all <code>Clone</code> then the function itself can be
cloned and called multiple times.</p>
</li>
<li>
<p>It is difficult to construct practical examples of this happening. The leakage
happens in the wrong direction (upstream) to be easily exploited whereas we
usually care about what is public to downstream crates.</p>
<p>Without specialization, the <code>Default</code> bound would have to be explicitly listed
which would then be readily visible to consumers of the upstream code.</p>
</li>
<li>
<p>Features like <code>impl Trait</code> make it relatively easy to avoid leaking this
capability when it's not wanted.</p>
</li>
</ul>
<p>Points for this argument:</p>
<ul>
<li>The <code>Clone</code> trait requires an existing instance of the function in order to be
exploited. The fact that the <code>Default</code> trait gives this capability to types
directly makes it sufficiently different from <code>Clone</code> to warrant a different
decision.</li>
</ul>
<p>These discussions also raise the question of whether the <code>Clone</code> trait itself
should be implemented automatically. It is convenient, but it leaves a very
grey area concerning which traits ought to be implemented for compiler-generated
types, and the most conservative option would be to require an opt-in for all
traits beyond the basic <code>Fn</code> traits (in the case of function types).</p>
<h3 id="unnatural-ness-of-using-default-trait"><a class="header" href="#unnatural-ness-of-using-default-trait">Unnatural-ness of using <code>Default</code> trait</a></h3>
<p>Several people objected on the grounds that <code>Default</code> was the wrong trait,
or that the resulting code seemed unnatural or confusing. This lead to
proposals involving other traits which will be described in their own
sections.</p>
<ul>
<li>
<p>Some people do not see <code>Default</code> as being equivalent to the
default-constructible concept from C++, and instead see it as something
more specialized.</p>
<p>To avoid putting words in people's mouths I'll quote @Mark-Simulacrum
directly:</p>
<blockquote>
<p>I think the main reason I'm not a fan of adding a Default impl here is
because you (probably) would never actually use it really as a &quot;default&quot;;
e.g. Vec::resize'ing with it is super unlikely. It's also not really a
Default but more just &quot;the only value.&quot; Certainly the error message telling
me that Default is not implemented for &amp;fn() {foo} is likely to be pretty
confusing since that does have a natural default too, like any pointer to
ZST). That's in some sense just more broadly true though.</p>
</blockquote>
</li>
<li>
<p>There were objections on the grounds that <code>Default</code> is not sufficient to
guarantee <em>uniqueness</em> of the function value. Code could be written today that
exposes a public API with a <code>Default + Fn()</code> bound, expecting all types
meeting that bound to have a single unique value.</p>
<p>If we expanded the set of types which could implement <code>Default + Fn()</code> (such
as by stabilizing <code>Fn</code> trait implementations or by making more function
types implement <code>Default</code>) then the assumptions of such code would be
broken.</p>
<p>On the other hand, we really can't stop people from writing faulty code and
this does not seem like a footgun people are going to accidentally use, in
part because it's so obscure.</p>
</li>
</ul>
<h3 id="new-lang-item"><a class="header" href="#new-lang-item">New lang-item</a></h3>
<p>This was a relatively minor consideration, but it is worth noting that this
solution would require making <code>Default</code> a lang item.</p>
<h2 id="safe-transmute"><a class="header" href="#safe-transmute">Safe transmute</a></h2>
<p>This proposal was to materialize the closure using the machinery being
added with the &quot;safe transmute&quot; RFC to transmute from the unit <code>()</code> type.</p>
<p>The details of how this would work in practice were not discussed in detail,
but there were some salient points:</p>
<ul>
<li>
<p>This solves the &quot;uniqueness&quot; problem, in that ZSTs are by definition unique.</p>
</li>
<li>
<p>It does not help with the &quot;privacy leakage&quot; concerns.</p>
</li>
<li>
<p>It opens up a new can of worms relating to the fact that ZST closure types
may still have upvars.</p>
</li>
<li>
<p>Several people expressed something along the lines of:</p>
<blockquote>
<p>if we were going to have a trait that allows this, it might as well be
Default, because telling people &quot;no, you need the special default&quot; doesn't
really help anything.</p>
</blockquote>
<p>Or, that if it's possible to do this one way with safe code, it should be
possible to do it in every way that makes sense.</p>
</li>
</ul>
<h2 id="singleton-or-zst-trait"><a class="header" href="#singleton-or-zst-trait"><code>Singleton</code> or <code>ZST</code> trait</a></h2>
<p>New traits were proposed to avoid using <code>Default</code> to materialize the function
values. The considerations here are mostly the same as for the &quot;safe
transmute&quot; propsal. One note is that if we <em>were</em> to add a <code>Singleton</code> trait,
it would probably make sense for that trait to inherit from the <code>Default</code>
trait anyway, and so a <code>Default</code> implementation now would be
backwards-compatible.</p>
<h2 id="fnstatic-trait"><a class="header" href="#fnstatic-trait"><code>FnStatic</code> trait</a></h2>
<p>This would be a new addition to the set of <code>Fn</code> traits which would allow
calling the function without any <code>self</code> argument at all. As the most
restrictive (for the callee) and least restrictive (for the caller) it
would sit at the bottom of the <code>Fn</code> trait hierarchy and inherit from <code>Fn</code>.</p>
<ul>
<li>Would be easy to understand for users already familiar with the <code>Fn</code> trait hierarchy.</li>
<li>More unambiguously describes a closure with no upvars rather than one which is a ZST.</li>
<li>Doesn't solve the problem of accidentally leaking capabilities.</li>
<li>Does not force a decision on whether closures should implement <code>Default</code>.</li>
</ul>
<p>This approach would also generalize the existing closure -&gt; function pointer
conversion for closures which have no upvars. Instead of being special-cased
in the compiler, the conversion can apply to all types implementing <code>FnStatic</code>.
Furthermore, the conversion could be implemented by simply returning a pointer
to the <code>FnStatic::call_static</code> function, which makes this very elegant.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>With this trait, we can implement <code>call_me_back_safely</code> from the prior example
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{panic, process};

pub fn call_me_back_safely&lt;F: FnStatic()&gt;(_f: F) {
    extern &quot;C&quot; fn catch_unwind_wrapper&lt;F: FnStatic()&gt;() {
        if panic::catch_unwind(F::call_static).is_err() {
            process::abort();
        }
    }
    unsafe {
        c_api::call_me_back(catch_unwind_wrapper::&lt;F&gt;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="const-eval"><a class="header" href="#const-eval">Const-eval</a></h2>
<p>Initially proposed by @scalexm, this solution uses the existing implicit
conversion from function types to function pointers, but in a const-eval
context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one_adapter&lt;const F: fn(i32)&gt;(arg: i32) {
    F(arg + 1);
}

fn get_adapted_function_ptr&lt;const F: fn(i32)&gt;() -&gt; fn(i32) {
    add_one_adapter::&lt;F&gt;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Avoids many of the pitfalls with implementing <code>Default</code>.</li>
<li>Requires giving up the original function type. There could be cases where
you still need the original type but the conversion to function pointer
is irreversible.</li>
<li>It's not yet clear if const-evaluation will be extended to support this
use-case.</li>
<li>Const evaluation has its own complexities, and given that we already have
unique function types, it seems like the original problem should be solvable
using the tools we already have available.</li>
</ul>
<h2 id="opt-in-trait-implementations"><a class="header" href="#opt-in-trait-implementations">Opt-in trait implementations</a></h2>
<p>This was barely touched on during the discussions, but one option would be to
have traits be opted-in via a <code>#[derive(...)]</code>-like attribute on functions and
closures.</p>
<ul>
<li>Gives a lot of power to the user.</li>
<li>Quite verbose.</li>
<li>Solves the problem of leaking capabilities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-traits"><a class="header" href="#auto-traits">Auto traits</a></h1>
<p>Auto traits permit automatically implementing a trait for types which contain
fields implementing the trait. That is, they are fairly close to an automatic
derive. They describe properties of types rather than behaviors; current stable
Rust has several auto traits: <code>Send</code>, <code>Sync</code>, <code>Unpin</code>, <code>UnwindSafe</code>,
<code>RefUnwindSafe</code>.</p>
<p><code>Freeze</code> is also an auto trait indirectly observable on stable; it is used by
the compiler to determine which types can be placed in read-only memory, for
example.</p>
<p>Auto traits are tracked in <a href="https://github.com/rust-lang/rust/issues/13231">rust-lang/rust#13231</a>, and are also sometimes
referred to as OIBITs (&quot;opt-in built-in traits&quot;).</p>
<p>As of November 2020, the language team feels that new auto traits are unlikely
to be added or stabilized. See <a href="https://zulip-archive.rust-lang.org/213817tlang/73585Freezestabilizationandautotraitbackcompat.html">discussion</a> on the addition of <code>Freeze</code> for
context. There is a fairly high burden to doing so on the ecosystem, as it
becomes a concern of every library author whether to implement the trait or not.</p>
<p>Each auto trait represents a semver compatibility hazard for Rust libraries, as
adding private fields can remove the auto trait unintentionally from a type.</p>
<p>Stabilizing the ability to define auto traits also allows &quot;testing&quot; for the
absence of a specific type:</p>
<pre><code class="language-ignore">auto trait NoString {}
impl !NoString for String {}
</code></pre>
<p>This is not something we generally want to allow, as it makes almost any change
to types semver breaking. That means that stabilizing defining new auto traits is
currently unlikely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eager-drop-design-note"><a class="header" href="#eager-drop-design-note">Eager drop design note</a></h1>
<ul>
<li>Project proposal <a href="https://github.com/rust-lang/lang-team/issues/86">rust-lang/lang-team#86</a></li>
</ul>
<h2 id="observations"><a class="header" href="#observations">Observations</a></h2>
<h3 id="any-attempt-to-make-drop-run-more-eagerly-will-have-to-take-borrows-into-account"><a class="header" href="#any-attempt-to-make-drop-run-more-eagerly-will-have-to-take-borrows-into-account">Any attempt to make drop run more eagerly will have to take borrows into account</a></h3>
<p>The original proposal was to use &quot;CFG dead&quot; as a criteria, but it's pretty clear that this will not work well. Example:</p>
<pre><pre class="playground"><code class="language-rust="><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = String::new();
    let y = &amp;x;
    // last use of x is here
    println!(&quot;{}&quot;, y);
    // but we use y here
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the fact that <code>y</code> (indirectly) uses <code>x</code> feels like an important thing to take into account.</p>
<h3 id="some-destructors-can-be-run-at-any-time"><a class="header" href="#some-destructors-can-be-run-at-any-time">Some destructors can be run &quot;at any time&quot;...</a></h3>
<p>Some destructors have very significant side-effects. The most notable example is dropping a lock guard.</p>
<p>Others correspond solely to &quot;releasing resources&quot;: freeing memory is the most common example, but another might be replacing an entry in a table because you are done using it.</p>
<h3 id="but-sometimes-that-significance-is-only-known-at-the-call-site"><a class="header" href="#but-sometimes-that-significance-is-only-known-at-the-call-site">...but sometimes that significance is only known at the call site</a></h3>
<p>However, it can be hard to know what is significant. For a lock guard, for example, if the lock is just being used to guard the data, then moving the lock release early is actually <em>desirable</em>, because you want to release the lock as soon as you are doing changing the data. But sometimes you have a <code>Mutex&lt;()&gt;</code>, in which case the lock has extra semantics. It's hard to know for sure.</p>
<h3 id="smarter-drop-placement-will-mean-that-adding-uses-of-a-variable-changes-when-its-destructor-runs"><a class="header" href="#smarter-drop-placement-will-mean-that-adding-uses-of-a-variable-changes-when-its-destructor-runs">Smarter drop placement will mean that adding uses of a variable changes when its destructor runs</a></h3>
<p>This is not necesarily a problem, but it's an obvious implication: right now, the drop always runs when we exit the scope, so adding further uses to a variable has no effect, but that would have to change. That could be surprising (e.g., adding a debug printout changes the time when a lock is released).</p>
<p>In contrast, if you add an early drop <code>drop(foo)</code> today, you get helpful error messages when you try to use it again.</p>
<p>In other words, it's useful to have the <em>destructor</em> occurring at a known time (sometimes...).</p>
<h3 id="todays-drop-rules-are-however-a-source-of-confusion"><a class="header" href="#todays-drop-rules-are-however-a-source-of-confusion">Today's drop rules are, however, a source of confusion</a></h3>
<p>The semantics of <code>let _ = &lt;expr&gt;</code> have been known to caught a lot of confusion, particularly given the interaction of place expressions and value expresssions:</p>
<ul>
<li><code>let _ = foo</code> -- no effect</li>
<li><code>let _ = foo()</code> -- immediately drops the result of invoking <code>foo()</code></li>
<li><code>let _guard = foo</code> -- moves <code>foo</code> into <code>_guard</code> and drops at the end of the block</li>
<li><code>let _guard = foo()</code> -- moves <code>foo()</code> into <code>_guard</code> and drops at the end of the block</li>
</ul>
<p>Another common source of confusion is the lifetimes of temporaries in <code>match</code> statements and the like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo.lock().data.copy_out() {
    ...
} // lock released here!
<span class="boring">}
</span></code></pre></pre>
<p><code>let guard = foo; ...; drop(guard);</code> has the advantage of explicitness, so does something like <code>foo.with(|guard| ...)</code></p>
<h3 id="clarity-for-unsafe-code-can-be-quite-important"><a class="header" href="#clarity-for-unsafe-code-can-be-quite-important">Clarity for unsafe code can be quite important</a></h3>
<p>There are known footguns today with the timing of destructors and unsafe code. For example, <code>CString::new().as_ptr()</code> is a common thing people try to do that does not work. Eager destructors would enable more motion, which might exacerbate the problem.</p>
<p>In addition, unsafe code means we might not be able to know the semantics associated with a destructor, such as what precisely a <code>Mutex&lt;()&gt;</code> guards, and moving a drop earlier <em>will</em> break some unsafe code in hard-to-detect ways.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<ul>
<li>Scoped methods</li>
<li>let blocks</li>
<li>&quot;Defer&quot; type constructs or scoped guard type constructs from other languages
<ul>
<li>Go</li>
<li>D</li>
<li>Python</li>
</ul>
</li>
<li>Built-in macros or RAII/closure-based helpers in the standard library.
<ul>
<li>Note that the <a href="https://crates.io/crates/scopeguard">scopeguard</a> crate offers macros like <code>defer!</code> that inject a let into the block.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autorefautoderef-in-operators"><a class="header" href="#autorefautoderef-in-operators">Autoref/Autoderef in operators</a></h1>
<p>Rust permits overriding most of the operators (e.g., <code>+</code>, <code>-</code>, <code>+=</code>). In part
due to <code>Copy</code> types not auto-dereferencing, it is common to have <code>T + &amp;T</code>
or <code>&amp;T + &amp;T</code>, with potentially many levels of indirection on either side of the
operator.</p>
<p>There is desire in general to avoid needing to both add impls for referenced
versions of types because they:</p>
<ul>
<li>bloat documentation</li>
<li>are never quite sufficient (always more references are possible)</li>
<li>can cause inference regressions, as the compiler cannot in general know that
<code>&amp;T + &amp;T</code> is essentially equivalent at runtime to <code>T + T</code>.</li>
</ul>
<p>The inference regressions are the primary target of historical discussions.</p>
<p>The tradeoff to some feature like this may either mean that the exact impl
executed at runtime is harder to determine, or that the compiler is
synthetically generating new implementations for some subset of types,
potentially adding confusion around which impls are actually present.</p>
<p>However, generic code may want the impls on references because the generic code
may not want to require <code>T: Copy</code>. One version of this could involve
something like <code>default impl&lt;T:Copy&gt; Add&lt;&amp;T&gt; for &amp;T</code> so that people don't <em>need</em>
to write special impls themselves. It's worth noting that this still would need
some special support in the compiler to avoid the two possible impls leading to
inference regressions.</p>
<h2 id="history-2"><a class="header" href="#history-2">History</a></h2>
<p>The standard library initially had just the basic impls of the operator traits
(e.g., <code>impl Add&lt;u64&gt; for u64</code>) but has since gained <code>&amp;u64 + &amp;u64</code>, <code>u64 + &amp;u64</code>
and <code>&amp;u64 + u64</code>. These impls usually cause some amount of inference breakage in
practice.</p>
<p>Especially with non-Copy types (for example bigints), forcing users to add references can be
increasingly verbose: <code>&amp;u * &amp;(&amp;(&amp;u.square() + &amp;(&amp;a * &amp;u)) + &amp;one)</code>, for example.</p>
<p>There have also been a number of discussions on RFCs and issues, including:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/44762">Rust tracking issue #44762</a>
<ul>
<li>This includes some implementation/mentoring notes.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2147">RFC 2147</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/41336">Trying to add T op= &amp;T</a>
<ul>
<li>Showcases dealing with inference breakage regressions when adding new
reference-taking impls.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-type-ergonomics"><a class="header" href="#copy-type-ergonomics">Copy type ergonomics</a></h1>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<p>There are a number of pain points with <code>Copy</code> types that the lang team is
interested in exploring, though active experimentation is not currently ongoing.</p>
<p>Some key problems are:</p>
<h2 id="copy-cannot-be-implemented-with-non-copy-members"><a class="header" href="#copy-cannot-be-implemented-with-non-copy-members"><code>Copy</code> cannot be implemented with non-<code>Copy</code> members</a></h2>
<p>There are standard library types where the lack of a <code>Copy</code> impl is an
active pain point, e.g., <a href="https://github.com/rust-lang/rust/issues/62835"><code>MaybeUninit</code></a>
and <a href="https://github.com/rust-lang/rust/issues/25053"><code>UnsafeCell</code></a>, when the
contained type is actually <code>Copy</code>.</p>
<h3 id="history-3"><a class="header" href="#history-3">History</a></h3>
<ul>
<li><code>unsafe impl Copy for T</code> which avoids the requirement that T is recursively
Copy, but is obviously unsafe.
<ul>
<li>https://github.com/rust-lang/rust/issues/25053#issuecomment-218610508</li>
</ul>
</li>
<li><code>Copy</code> is dangerous on types like <code>UnsafeCell</code> where <code>&amp;UnsafeCell&lt;T&gt;</code>
otherwise would not permit access to <code>T</code> in <a href="https://github.com/rust-lang/rust/issues/25053#issuecomment-98447164">safe
code</a>.</li>
</ul>
<h2 id="copy-types-can-be-unintentionally-copied"><a class="header" href="#copy-types-can-be-unintentionally-copied"><code>Copy</code> types can be (unintentionally) copied</a></h2>
<p>Even if a type is Copy (e.g., <code>[u8; 1024]</code>) it may not be a good idea to make
use of that in practice, since copying large amounts of data is slow. This is
primarily a performance concern, so the problem is usually that these copies are
easy to miss. However, depending on the size of the buffer, it can also be a
correctness concern as it may cause an unintended stack overflow with too many
accidental copies.</p>
<p>Should we want to lint on this code, deciding on a size threshold may be
difficult. It's not generally possible for the compiler to know whether a
particular copy operation is likely to lead to stack overflow or undesirable
performance. We don't have examples yet of cases where there's desirable large
copies (that should not be linted against) or concrete cases where the copies
are accidental; collecting this information would be worthwhile.</p>
<p>Implementations of <code>Copy</code> on closures and arrays are the prime example of Rust
currently being overeager with the defaults in some contexts.</p>
<p>This also comes up with <code>Copy</code> impls on <code>Range</code>, which would generally be
desirable but is error-prone given the <code>Iterator/IntoIterator</code> impls on ranges.</p>
<p>The example here does not compile today (since Range is not Copy), but would be
unintuitive if it did.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0..10;
let mut c = move || x.next();
println!(&quot;{:?}&quot;, x.next()); // prints 0
println!(&quot;{:?}&quot;, c()); // prints 0, because the captured x is implicitly copied.
<span class="boring">}
</span></code></pre></pre>
<p>This example illustrates the range being copied into the closure, while the user
may have expected the name &quot;x&quot; to refer to the same range in both cases.</p>
<p>The move keyword here likely disambiguates this particular case for users, but
in closures with more captures it may be not as obvious that the range type in
particular was copied in.</p>
<p>A lint has been <a href="https://github.com/rust-lang/rust/issues/45683">proposed</a> to
permit Copy impls on types where Copy is likely not desirable with particular
conditions (e.g., Copy of IntoIterator-implementing types after iteration).</p>
<p>Note that &quot;large copies&quot; comes up with moves as well (which are copies, just
taking ownership as well), so a size-based lint is plausibly desirable for both.</p>
<h3 id="history-4"><a class="header" href="#history-4">History</a></h3>
<ul>
<li>Proposed lint: <a href="https://github.com/rust-lang/rust/issues/45683">#45683</a></li>
</ul>
<h2 id="references-to-copy-types"><a class="header" href="#references-to-copy-types">References to <code>Copy</code> types</a></h2>
<p>Frequently when dealing with code generic over T you end up needing things like
<code>[u8]::contains(&amp;5)</code> which is ugly and annoying. Iterators of copy types also
produce <code>&amp;&amp;u64</code> and similar constructs which can produce unexpected type errors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for x in &amp;vec![1, 2, 3, 4, 5, 6, 7] {
    process(*x); // &lt;-- annoying that we need `*x`
}

fn process(x: i32) { }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_even(v: &amp;[u32]) -&gt; u32 {
    // **v is annoying
    v.iter().filter(|v| **v % 2 == 0).sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this means that you in most cases want to &quot;boil down&quot; to the inner
type when dealing with references, i.e., <code>&amp;&amp;u32</code> you actually want <code>u32</code>, not
<code>&amp;u32</code>. Notably, though, this may <em>not</em> be true if the Copy type is something
more complex (e.g., a future Copy Cell), since then <code>&amp;Cell</code> is quite different
from a <code>Cell</code>, the latter being likely useless for modification at least.</p>
<p>There is also plausibly performance left on the table with types like <code>&amp;&amp;u64</code>.</p>
<p>Note that this interacts with the unintentional copies (especially of large
structures).</p>
<p>This could plausibly be done with moved values as well, so long as the
semantics match the syntax (e.g. <code>wants_ref(foo)</code> acts like <code>wants_ref(&amp;{foo})</code>)
similar to how one can pass <code>&amp;mut</code> to something that only wants <code>&amp;</code>.
This would be a tradeoff: in some cases people may want the type-checker to flag such cases and require explicitly taking a reference, while in other cases people may want the compiler to automatically make such code work. We would want to consider and evaluate this tradeoff, and whether we can usefully separate such cases.</p>
<h3 id="history-5"><a class="header" href="#history-5">History</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2111">RFC 2111 (not merged)</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/44763">Rust tracking issue (closed)</a></li>
<li>&quot;Allow owned values where references are expected&quot; in <a href="https://github.com/rust-lang/rust-roadmap-2017/issues/17">rust-roadmap-2017#17</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>This section contains lang-team roadmaps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lang-team-roadmap-2024"><a class="header" href="#lang-team-roadmap-2024">Lang Team Roadmap 2024</a></h1>
<p>Rust 1.0 was released in 2015. Since that time, we've seen Rust grow from a
small language used for a handful of prominent projects into a mainstay in use
at virtually every major tech company.</p>
<p>As we work towards Rust 2024, it's natural to ask what's next for the language.
This roadmap provides insight into that question by describing what we, as
members of the lang team with input from other Rust teams, would like to
prioritize.</p>
<p>We have two goals with this roadmap:</p>
<ul>
<li>to give people a sense for what to expect in Rust over the next few years;</li>
<li>for those who would like to contribute to Rust, to help provide &quot;starting
points&quot; for how to get involved, and a sense for what kind of projects we are
looking for.</li>
</ul>
<h2 id="rust-2024-scaling-empowerment"><a class="header" href="#rust-2024-scaling-empowerment">Rust 2024: scaling empowerment</a></h2>
<p>Rust's goal is to <strong>empower everyone to build reliable and efficient
software</strong>. Success requires not only designing and implementing a great
language with great libraries and great tools, but also maintaining a great and
supportive community.</p>
<p>Our focus for Rust 2024 is to <strong>scale empowerment</strong> in many different ways. As
we grow, we face increasing challenges in how we can scale the ways in which we
empower people to an increasing number of people. This roadmap presents three
general themes we plan to focus on:</p>
<ul>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Flatten-the-learning-curve">Flatten the (learning) curve</a></strong>:
scaling to new users and new use cases
<ul>
<li>Make Rust more accessible to new and existing users alike, and make
solving hard problems easier.</li>
</ul>
</li>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Help-users-help-each-other">Help Rust's users help each other</a></strong>:
scaling the ecosystem
<ul>
<li>Empower library authors so they can---in turn---empower their users.</li>
</ul>
</li>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Help-the-Rust-project-scale">Help the Rust project scale</a></strong>:
scaling the project
<ul>
<li>Develop processes to scale to the needs and use cases of a growing number
of users; evaluate and finish projects we've started.</li>
</ul>
</li>
</ul>
<p>For each theme, we'll describe our goals for Rust 2024, and give a few examples
of the kinds of things that we're working on right now, as well as the kinds of
things we would like to do over the next few years.</p>
<p>This roadmap is a starting point. Our intent is to highlight those areas that
will have the biggest impact on Rust's success. Specific examples will change
over time, whether because they're finished or because new proposals arise. As
2023 approaches, we will revisit these themes to see how much progress we have
made, and whether we wish to adjust the list.</p>
<h2 id="theme-flatten-the-learning-curve"><a class="header" href="#theme-flatten-the-learning-curve">Theme: Flatten the (learning) curve</a></h2>
<h3 id="the-vision"><a class="header" href="#the-vision">The vision</a></h3>
<p>Thanks to a consistent focus on ergonomics, Rust has become considerably easier
to use over the last few years. Companies building large teams of Rust users
report that the typical onboarding time for a Rust engineer is around 3-6
months. Of course, once folks learn Rust, they typically love it. Even so, many
people report a sense of high &quot;cognitive overhead&quot; in using it, and &quot;learning
curve&quot; remains the most common reason not to use Rust. The fact is that, even
after you learn how the Rust borrow checker works, there remain a lot of &quot;small
details&quot; that you have to get just right to get your Rust program to compile.</p>
<p>For Rust 2024, we will identify and eliminate many of those patterns and
idiosyncracies that one must learn to use Rust; our goal is to let you focus
squarely on the &quot;inherent complexity&quot; of your problem domain and avoid
&quot;accidental complexity&quot; from Rust as much as possible.</p>
<p>Async and embedded Rust are areas of particular interest. We have made a lot of
strides to support those areas, and they are growing rapidly. Nonetheless, Rust
lacks many core capabilities that would be required to make working in those
domains not only <em>possible</em> but <em>straightforward and delightful</em>. For Rust
2024, we will close that gap.</p>
<p>Our plan for achieving this vision is to focus on four high-level goals (in
order from broad to precise):</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong> Make the compiler better able to
recognize when code is correct via improvements to the borrow checker, type
inference, and so forth. Identify and eliminate &quot;boilerplate&quot; patterns like
having to copy-and-paste the same set of where clauses everywhere.</li>
<li><strong>Express yourself more easily:</strong> Where necessary, extend the language so you
can express what you want your code to do more directly. In some cases this
takes the form of syntactic sugar (such as
<a href="https://github.com/rust-lang/rust/issues/87335">let-else</a>) but in other
cases it may mean extending the type system to be able to describe new
patterns (such as <a href="https://rust-lang.github.io/generic-associated-types-initiative/">generic associated
types</a>).</li>
<li><strong>Improve async support:</strong> Extend our async-await support beyond the current
&quot;MVP&quot; to include features like async fns in traits, async drop, and other
features needed to support the <a href="https://rust-lang.github.io/wg-async/vision/roadmap.html">async vision
document</a> roadmap.</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong> Broaden the set of traits that can be used
with <code>dyn</code> and make working with <code>dyn</code> closer to working with generics.</li>
</ul>
<h3 id="how-you-can-help"><a class="header" href="#how-you-can-help">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to nikomatsakis if you'd like to discuss
privately first.</p>
<h3 id="the-plan-so-far"><a class="header" href="#the-plan-so-far">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong>
<ul>
<li>Non-lexical lifetimes were a big stride forward, but the <a href="https://github.com/rust-lang/polonius/">polonius
project</a> promises to improve the
borrow check's precision even more.</li>
<li><a href="https://github.com/rust-lang/rust/issues/44491">Implied bounds</a> promise
to remove a lot of copy-and-pasting of where clauses.</li>
</ul>
</li>
<li><strong>Express yourself more easily:</strong>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/87335">let-else</a> directly
express the &quot;match this variant or <code>return</code>/<code>continue</code>/etc&quot; pattern.</li>
<li><a href="https://github.com/rust-lang/rust/issues/53667">let-chains</a> allow you to
express iterative refinement with a series of pattern-matches and
conditionals</li>
<li><a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">&quot;Type alias&quot; impl
Trait</a>
permits APIs to name previously unnameable types. This is part of a
larger effort to <a href="https://rust-lang.github.io/impl-trait-initiative/">expand impl
Trait</a>.</li>
<li><a href="https://rust-lang.github.io/generic-associated-types-initiative/">Generic associated
types</a>
allow traits to express a number of patterns (like &quot;iterable&quot;) that the
current trait system cannot handle. They are a particularly important
foundational piece for async programming.</li>
</ul>
</li>
<li><strong>Improve async support:</strong>
<ul>
<li>We are working to support <a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_traits.html">async fns in
traits</a>,
including both static dispatch and dyn dispatch.</li>
</ul>
</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong>
<ul>
<li><a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative/issues/6">Dyn upcasting coercion
initiative</a>:
Allow upcasting <code>dyn trait</code> objects from <code>&amp;dyn Subtrait</code> to <code>&amp;dyn Supertrait</code>.</li>
<li>The <a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_traits.html">async fn in
traits</a>
initiative is also extending dyn trait to support async fns and &quot;return
position impl Trait&quot;.</li>
</ul>
</li>
</ul>
<h3 id="looking-forward"><a class="header" href="#looking-forward">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. <strong>For many of
these ideas, the main thing they need is someone to own the design!</strong> If you
might be interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to nikomatsakis.</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong>
<ul>
<li><a href="https://github.com/rust-lang/lang-team/issues/88">Deref patterns</a>:
Permit matching types with patterns they can dereference to, such as
matching a <code>String</code> with a <code>&quot;str&quot;</code>.</li>
<li>Perfect derive: determine the precise conditions for generic type
parameters based on the types of a struct fields. For instance,
<code>#[derive(Clone)] struct MyStruct(Rc&lt;T&gt;)</code> would not require <code>T: Clone</code>,
because <code>Rc&lt;T&gt;</code> can be cloned without it.</li>
<li>Autoref, operators, and clones: Generic methods that operate on
references sometimes necessitate types like <code>&amp;u32</code>; since <code>u32</code> is
<code>Copy</code>, we could automatically make it a reference. We've historically
had some hesitance to add more reference-producing operations, because it
can lead to types the user doesn't expect (such as <code>&amp;&amp;&amp;str</code>). We have
some ideas to simplify those cases and avoid unnecessary
double-references.</li>
</ul>
</li>
<li><strong>Express yourself more easily:</strong>
<ul>
<li><a href="https://github.com/rust-lang/lang-team/issues/137">Generators</a>, allowing
users to write iterators (async and otherwise) using custom syntax.</li>
</ul>
</li>
<li><strong>Improve async support:</strong>
<ul>
<li>After adding async fn in traits, we intend to add support for async drop,
async closures, and potentially other features.</li>
</ul>
</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong>
<ul>
<li>Make more patterns &quot;object safe&quot; and thus usable in <code>dyn Trait</code> objects,
including passing <code>self</code> by value and handling <code>impl Trait</code> in argument
position (<a href="https://smallcultfollowing.com/babysteps/blog/2022/01/07/dyn-async-traits-part-7/">see this post for more
information</a>).</li>
</ul>
</li>
</ul>
<h2 id="theme-help-users-help-each-other"><a class="header" href="#theme-help-users-help-each-other">Theme: Help users help each other</a></h2>
<h3 id="the-vision-1"><a class="header" href="#the-vision-1">The vision</a></h3>
<p>Rust's combination of ownership and borrowing, low-level systems control, and
powerful extensibility mechanisms like procedural macros makes it a great
language for writing libraries. And, thanks to Cargo, using a library in your
program only takes a few lines of code. Nonetheless, there are a number of
things that library authors <em>can't</em> do, or can't do easily -- for example, they
can't control the error messages you see or deploy an &quot;unstable&quot; feature that
requires special opt-in to use. For Rust 2024, we want to build features that
empower library authors to better serve their users, either by helping to
manage the feature lifecycle or by expanding the capabilities of what a library
can do.</p>
<p>We encourage people to experiment and explore in the library ecosystem,
building new functionality for people to use. Sometimes, that new functionality
becomes a foundation for others to build on, and standardizing it simplifies
further development atop it, letting the cycle continue at another level.
However, some aspects of the Rust language (notably coherence) make it harder
to extend the Rust standard library or well-established crates from separate
libraries, discouraging experimentation. Other features (such as aspects of
method resolution) make it hard to promote best-in-class functionality into the
standard library or into well-established crates without breaking users of the
crates that first developed that functionality. For Rust 2024, we want to
pursue changes that enable more exploration in the ecosystem, and enable stable
migration of code from the ecosystem into the standard library.</p>
<p>Our plan for achieving this vision is to focus on four categories of work:</p>
<ul>
<li><strong>Feature lifecycle</strong>: Help library authors support features as they move
from experimental to finalized. Help library authors manage their development
lifecycle and evolution.</li>
<li><strong>Richer abstractions</strong>: Extend the language to let library authors express
richer abstractions.</li>
<li><strong>Custom developer experience</strong>: Permit library authors can tailor the
developer experience, for example by tailoring the error messages a user gets
when traits are not implemented or introducing custom lints.</li>
<li><strong>Interoperability</strong>: The library ecosystem can easily coordinate, making
libraries work together without tying them together. Library authors can
write code that is portable across many environments or specific to one, as
they please.</li>
</ul>
<h3 id="how-you-can-help-1"><a class="header" href="#how-you-can-help-1">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to Josh Triplett if you'd like to discuss
privately first.</p>
<h3 id="the-plan-so-far-1"><a class="header" href="#the-plan-so-far-1">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>Feature lifecycle:</strong>
<ul>
<li>RFC 3240 proposes <a href="https://github.com/rust-lang/rfcs/pull/3240">edition-based method
disambiguation</a>, to support
moving extension methods from external crates into the standard library.</li>
</ul>
</li>
<li><strong>Richer abstractions:</strong>
<ul>
<li>There are numerous core extensions to Rust's type system that permit
richer traits to be developed. Often the lack of these features prohibits
people from writing general purpose libraries because they can't get
sufficient reuse:
<ul>
<li><a href="https://rust-lang.github.io/async-fundamentals-initiative/">Async fn in
traits</a></li>
<li><a href="https://github.com/rust-lang/lang-team/issues/51">Const generics</a>
and <a href="https://github.com/rust-lang/lang-team/issues/22">constant
evaluation</a></li>
<li><a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">Type alias impl
Trait</a></li>
<li><a href="https://rust-lang.github.io/generic-associated-types-initiative/">Generic associated
types</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Custom developer experience:</strong>
<ul>
<li>We are not currently doing any coordinated initiatives here, though there
are ongoing efforts that help lay groundwork for this.</li>
</ul>
</li>
<li><strong>Interoperability:</strong>
<ul>
<li>Support &quot;global capabilities&quot; like allocators or async runtimes, perhaps
via an approach like <a href="https://github.com/rust-lang/rfcs/pull/2492">RFC
2492</a>, and perhaps extending
to something like <a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">scoped contexts and
capabilities</a>.</li>
<li><a href="https://rust-lang.github.io/negative-impls-initiative/">Negative impls in
coherence</a> allows
for more flexibility in the coherence check by permitting crates to
explicitly declare that a given type will never implement a given trait.</li>
<li>The async working group's <a href="https://www.ncameron.org/blog/portable-and-interoperable-async-rust/">portability
initiative</a>
(which builds on the work to support <a href="https://rust-lang.github.io/async-fundamentals-initiative/">async fn in
traits</a>) will
help the async ecosystem to grow by enabling more interoperability.</li>
</ul>
</li>
</ul>
<h3 id="looking-forward-1"><a class="header" href="#looking-forward-1">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. <strong>For many of
these ideas, the main thing they need is someone to own the design!</strong> If you
might be interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to Josh Triplett.</p>
<ul>
<li><strong>Feature lifecycle</strong>:
<ul>
<li>All ecosystem crates can have &quot;release trains&quot;, with the equivalent of
&quot;nightly features&quot; that require a stability opt-ins. Top-level crates
retain control over whether any of their dependencies may use nightly
features.</li>
</ul>
</li>
<li><strong>Richer abstractions</strong>:
<ul>
<li>Allow libraries to implement the <code>Fn</code> traits to define callable objects.</li>
<li>Variadic tuples and variadic generics would address a common pain point
of &quot;implement this trait for tuples of any arity&quot;.</li>
</ul>
</li>
<li><strong>Custom developer experience</strong>:
<ul>
<li>Allow libraries to provide custom lints for their users.</li>
<li>Allow libraries to control or customize Rust diagnostics, especially for
trait resolution failures.</li>
</ul>
</li>
<li><strong>Interoperability</strong>:
<ul>
<li>Revive the stalled <a href="https://github.com/rust-lang/rfcs/pull/1868">portability
lint</a> or pursue an
alternative design (a recent suggestion is that the &quot;platform&quot; might be a
global service, similar to <a href="https://github.com/rust-lang/rfcs/pull/2492">RFC
2492</a>, permitting one to use
where clauses to designate portable code)</li>
<li>The coherence rules make it hard to implement interoperability traits; we
should find a way to lift this restriction, while preserving coherence's
key benefits.</li>
<li>Adopt a standard way to write performance benchmarks (perhaps simply
adopt <code>criterion</code> officially).</li>
<li>Better support for dynamic linking, with richer and safer types than the
C ABI. For instance, implement an <code>extern &quot;safe&quot;</code> providing a subset of
Rust's rich types.</li>
</ul>
</li>
</ul>
<h2 id="theme-help-the-rust-project-scale"><a class="header" href="#theme-help-the-rust-project-scale">Theme: <strong>Help the Rust project scale</strong></a></h2>
<h3 id="the-vision-2"><a class="header" href="#the-vision-2">The vision</a></h3>
<p>The Rust repo is a blizzard of activity. This is great, but it can be
overwhelming, particularly if you are trying to figure out the status of some
particular thing that you are interested in or would like to contribute to.</p>
<p>To ship Rust 2024 and make Rust all that it can be, we need a system that makes
it easy for people to find out what's going on and how they can help. We want
to scale our language development through delegation, empowering developers to
own and drive the work that they are passionate about. Lang team liaisons and
frequent lang team check-in will help ensure quality, stability, and overall
coherence. The team itself will have a clear &quot;path to membership&quot; that helps us
to maintain our membership and make sure we have the expertise we need.</p>
<p>Our plan for achieving this vision is to focus on four categories of work:</p>
<ul>
<li><strong>See the status at a glance:</strong> We want it to be easy to identify what things
the lang-team is actively working on and how far those designs have come. We
want every tracking issue to clearly identify what &quot;next steps&quot; are needed to
push that particular feature over the finish line and make sure that those
steps are clearly documented for would-be contributors.</li>
<li><strong>Clear owners and clear communication:</strong> Rust operates by consensus, but
that doesn't mean that everybody has to know all the details of everything.
We need a system that has clear owners for the work to be done, and ideally,
owners that are not on the lang team. Simply dividing work though can lead to
conflicts later on, so we also need frequent communication and updates to
ensure that everyone is keeping abreast of the overall direction things are
going, and to surface concerns early.</li>
<li><strong>Efficient, open processes with tooling support:</strong> We are always looking for
ways to improve how we operate to help us stay on top of what is going on in
the Rust project and to reach conclusions more quickly. One thing we've
noticed is that processes that are supported by bots or other tooling tend to
work much better.</li>
</ul>
<h3 id="how-you-can-help-2"><a class="header" href="#how-you-can-help-2">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to Josh Triplett and nikomatsakis if you'd
like to discuss privately first.</p>
<h3 id="the-plan-so-far-2"><a class="header" href="#the-plan-so-far-2">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>See the status at a glance:</strong>
<ul>
<li>The <a href="https://github.com/orgs/rust-lang/projects/16/">initiative project
board</a> tracks all the
currently active initiatives that we are focusing on. For each one, it
shows their <a href="https://lang-team.rust-lang.org/initiatives/process/stages.html">current
stage</a>
along with their
<a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">owners</a>
and <a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">lang-team
liaisons</a>.</li>
<li>During the <a href="https://lang-team.rust-lang.org/meetings/backlog-bonanza.html">backlog
bonanza</a>
meetings, we are going through each older tracking issue and identifying
what kinds of work is needed to move it forward (needs a summary, needs
design work, etc).</li>
<li>We're taking the time to stabilize features that people are using, and
remove incomplete features as well as features people are not using, with
the eventual goal of treating everything open as &quot;in-flight&quot; rather than
&quot;unknown&quot;. We will also reduce the total number of in-flight features.</li>
</ul>
</li>
<li><strong>Clear owners and clear communication:</strong>
<ul>
<li>The <a href="https://lang-team.rust-lang.org/initiatives.html">initiative system</a>
assigns each task an owner, who drives the design, as well as a lang-team
liaison, who helps ensure alignment with the team. More work is needed to
get this system up and running smoothly.</li>
<li>We are launching a <a href="https://hackmd.io/@nikomatsakis/rJ3h_-kJc">formality
team</a> that will take ownership
of ensuring Rust's type soundness and diving into the details. This will
help to grow the set of people with expertise in that area while also
allowing the main lang team to consult as needed.</li>
</ul>
</li>
<li><strong>Efficient, open processes with tooling support:</strong>
<ul>
<li>We have designed a new <a href="https://lang-team.rust-lang.org/decision_process.html">consensus decision
process</a> that is
designed to overcome some of the shortcomings we've seen with rfcbot; it
needs to be implemented. This will help us make easily reversible
decisions easier, enable more experimentation, make it smoother to raise
and resolve concerns, and keep track of potential issues from proposal
through to stabilization</li>
</ul>
</li>
</ul>
<h3 id="looking-forward-2"><a class="header" href="#looking-forward-2">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. If you might be
interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to Josh Triplett and nikomatsakis.</p>
<ul>
<li><strong>See the status at a glance:</strong>
<ul>
<li>Find ways to integrate the older tracking issues with active initiatives;
reduce the manual updates required to keep the project board in sync.</li>
<li>Improve the visualization of projects and blockers to something more
compelling and easier to follow.</li>
</ul>
</li>
<li><strong>Clear owners and clear communication:</strong>
<ul>
<li>Beyond the type system, there are other areas where forming specialized
teams could be useful.</li>
</ul>
</li>
<li><strong>Efficient, open processes with tooling support:</strong>
<ul>
<li>Generally improve rustbot to make meetings more efficient.</li>
<li>Improve and automate the process of going from initiative proposal to
tracked initiative.</li>
</ul>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We hope that this post has given you a taste for what we plan to focus on over
the next few years. If you'd like to help us reach these goals, please <a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024">get
involved</a>!
We've listed a number of active initiatives for each point, but we've also
included a lot of ideas that are looking for an owner. Whether you prefer to
code, design, document, or organize, there's work for you to do. And if the
only thing you want to do with Rust 2024 is to use it, we welcome that too.
Happy Rust hacking to y'all!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
