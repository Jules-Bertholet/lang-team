---
title: Triage meeting 2022-07-12
tags: triage-meeting
---

# T-lang meeting agenda

* Meeting date: 2022-07-12

## Attendance

* Team members: nikomatsakis, josh
* Others: Mark, Tyler

## Meeting roles

* Action item scribe: simulacrum
* Note-taker: nikomatsakis

## Scheduled meetings
- "Structural equality" [lang-team#94](https://github.com/rust-lang/lang-team/issues/94) 
- "Never allow unwinding from Drop impls" [lang-team#97](https://github.com/rust-lang/lang-team/issues/97) 
- "Dyn upcasting, safety considerations" [lang-team#119](https://github.com/rust-lang/lang-team/issues/119) 
- "Const eval overview" [lang-team#131](https://github.com/rust-lang/lang-team/issues/131) 
- "Return Position impl Trait in dyn Trait ("RPITIDT")" [lang-team#144](https://github.com/rust-lang/lang-team/issues/144) 

## Announcements or custom items

### GAT Stabilization

* Created a [MVP page](https://rust-lang.github.io/generic-associated-types-initiative/mvp.html) that covers the main points that came up during stabilization
* Moved to [fcp merge](https://github.com/rust-lang/rust/pull/96709#issuecomment-1181931456), the comment summarizes the concerns etc

## Action item review

* [Action items list](https://hackmd.io/gstfhtXYTHa3Jv-P_2RK7A)

## Pending lang team project proposals
### "Deprecate target_vendor " lang-team#102

**Link:** https://github.com/rust-lang/lang-team/issues/102

### "Support platforms with size_t != uintptr_t" lang-team#125

**Link:** https://github.com/rust-lang/lang-team/issues/125

### "Positional Associated Types" lang-team#126

**Link:** https://github.com/rust-lang/lang-team/issues/126

### "Interoperability With C++ Destruction Order" lang-team#135

**Link:** https://github.com/rust-lang/lang-team/issues/135

### "allow construction of non-exhaustive structs when using functional update syntax" lang-team#143

**Link:** https://github.com/rust-lang/lang-team/issues/143

### "Add #[deprecated_safe] attribute to allow functions be be marked unsafe in a backwards compatible fashion" lang-team#147

**Link:** https://github.com/rust-lang/lang-team/issues/147

### "Async fns in traits" lang-team#150

**Link:** https://github.com/rust-lang/lang-team/issues/150

### "dyn* trait" lang-team#158

**Link:** https://github.com/rust-lang/lang-team/issues/158

### "Initiative: `?` traits, `try` blocks, `yeet` exprs, oh my" lang-team#160

**Link:** https://github.com/rust-lang/lang-team/issues/160

### "Initiative: Ghost types and blocks" lang-team#161

**Link:** https://github.com/rust-lang/lang-team/issues/161

### "Keyword generics" lang-team#162

**Link:** https://github.com/rust-lang/lang-team/issues/162

### "Add const evaluatable `where const { <block> }`" lang-team#163

**Link:** https://github.com/rust-lang/lang-team/issues/163

### "#[repr(Interoperable_2024)]" lang-team#165

**Link:** https://github.com/rust-lang/lang-team/issues/165

joshtriplett: The person who is driving this is still interested. I suggested making a summary. Conversation seems to have died down, unclear whether folks lost interest or didn't have more points to make.

## PRs on the lang-team repo
### "Note design constraints on hypothetical `DynSized`" lang-team#166

**Link:** https://github.com/rust-lang/lang-team/pull/166



## RFCs waiting to be merged
### "Refined trait implementations" rfcs#3245

**Link:** https://github.com/rust-lang/rfcs/pull/3245



## Proposed FCPs

**Check your boxes!**
### "Tracking issue for `#![register_attr]`" rust#66080

- **Link:** https://github.com/rust-lang/rust/issues/66080
- [**Tracking Comment**](https://github.com/rust-lang/rust/issues/66080#issuecomment-1170274903): 
	> Team member @joshtriplett has proposed to close this. The next step is review by the rest of the tagged team members:
	> 
	> * [ ] @cramertj
	> * [x] @joshtriplett
	> * [ ] @nikomatsakis
	> * [ ] @pnkfelix
	> * [x] @scottmcm
	> 
	> No concerns currently listed.
	> 
	> Once a majority of reviewers approve (and at most 2 approvals are outstanding), this will enter its final comment period. If you spot a major issue that hasn't been raised at any point in this process, please speak up!
	> 
	> See [this document](https://github.com/rust-lang/rfcbot-rs/blob/master/README.md) for info about what commands tagged team members can give me.
- [**Initiating Comment**](https://github.com/rust-lang/rust/issues/66080#issuecomment-1170274839): 
	> > It's quite possible that all the uses should migrate to #![register_tool] (https://github.com/rust-lang/rust/issues/66079) instead.
	> 
	> We discussed this in today's @rust-lang/lang meeting, and we agreed: anything new should be scoped, and anything existing we need to support for backwards compatibility shouldn't require calling `register_tool` first, so we can just keep the hardcoding of the handful of exceptions in the compiler.
	> 
	> @rfcbot close


### "Stabilize `let else`" rust#93628

- **Link:** https://github.com/rust-lang/rust/pull/93628
- [**Tracking Comment**](https://github.com/rust-lang/rust/pull/93628#issuecomment-1029383585): 
	> Team member @joshtriplett has proposed to merge this. The next step is review by the rest of the tagged team members:
	> 
	> * [x] @cramertj
	> * [x] @joshtriplett
	> * [x] @nikomatsakis
	> * [x] @pnkfelix
	> * [ ] @scottmcm
	> 
	> Concerns:
	> 
	> * need-consistency-rvalue-temporary-rules-between-let-and-let-else (https://github.com/rust-lang/rust/pull/93628#issuecomment-1055738523)
	> * ~~not-while-rustfmt-breaks-on-it~~ resolved by https://github.com/rust-lang/rust/pull/93628#issuecomment-1032936704
	> * ~~semicolon~~ resolved by https://github.com/rust-lang/rust/pull/93628#issuecomment-1059799661
	> * ~~stabilization-report~~ resolved by https://github.com/rust-lang/rust/pull/93628#issuecomment-1033846359
	> * ~~summarize-concerns~~ resolved by https://github.com/rust-lang/rust/pull/93628#issuecomment-1056785904
	> 
	> Once a majority of reviewers approve (and at most 2 approvals are outstanding), this will enter its final comment period. If you spot a major issue that hasn't been raised at any point in this process, please speak up!
	> 
	> See [this document](https://github.com/rust-lang/rfcbot-rs/blob/master/README.md) for info about what commands tagged team members can give me.
- [**Initiating Comment**](https://github.com/rust-lang/rust/pull/93628#issuecomment-1029383577): 
	> Shall we stabilize `let else` syntax? We've had many demonstrated uses, including extensively throughout `rust-lang/rust`, we've seen the value of it, and there aren't any known issues with it.
	> 
	> @rfcbot merge

No update at present. There's a PR under review.

### "Stabilize generic associated types" rust#96709

- **Link:** https://github.com/rust-lang/rust/pull/96709
- [**Tracking Comment**](https://github.com/rust-lang/rust/pull/96709#issuecomment-1181931476): 
	> Team member @nikomatsakis has proposed to merge this. The next step is review by the rest of the tagged team members:
	> 
	> * [ ] @compiler-errors
	> * [ ] @cramertj
	> * [x] @jackh726
	> * [ ] @joshtriplett
	> * [ ] @lcnr
	> * [x] @nikomatsakis
	> * [ ] @oli-obk
	> * [ ] @pnkfelix
	> * [ ] @scottmcm
	> * [ ] @spastorino
	> 
	> No concerns currently listed.
	> 
	> Once a majority of reviewers approve (and at most 2 approvals are outstanding), this will enter its final comment period. If you spot a major issue that hasn't been raised at any point in this process, please speak up!
	> 
	> See [this document](https://github.com/rust-lang/rfcbot-rs/blob/master/README.md) for info about what commands tagged team members can give me.
- [**Initiating Comment**](https://github.com/rust-lang/rust/pull/96709#issuecomment-1181931456):
	> @rfcbot fcp merge
	> 
	> Hello all. As the liaison for the generic associated types initiative, I'd like to move to stabilize the MVP of generic-associated-types. The thread has raised up a lot of questions and considerations for the teams to answer. I'm going to break down these questions here. I've also prepared a [page on the GAT repository](https://rust-lang.github.io/generic-associated-types-initiative/mvp.html) that contains pointers and links to both explain *what* is being stabilized but also the concerns raised on the thread, along with counterpoints, if you'd like to read more. ([Endorsed](https://github.com/rust-lang/rust/pull/96709#issuecomment-1181852925) by @BurntSushi, no less :grin:)
	> 
	> ### Questions for T-lang
	> 
	> #### Do we want to expose GATs directly or only use them internally to enable other features? 
	> 
	> GATs are needed internally to model traits that include [async functions] and [return-position impl trait][RPIT]. As a stand-alone feature, they permit users to capture patterns in code that couldn't previously be expressed, whether that is a trait like [`Iterable`] or something more abstract like the [generic scopes] or [many modes] pattern.
	> 
	> [async functions]: https://rust-lang.github.io/async-fundamentals-initiative/roadmap/static_async_trait.html
	> [RPIT]: https://rust-lang.github.io/impl-trait-initiative/explainer/rpit_trait.html
	> [`Iterable`]: https://rust-lang.github.io/generic-associated-types-initiative/design_patterns/iterable.html
	> [generic scopes]: https://rust-lang.github.io/generic-associated-types-initiative/design_patterns/generic_scopes.html
	> [many modes]: https://rust-lang.github.io/generic-associated-types-initiative/design_patterns/many_modes.html
	> 
	> But that strength also means that users will create libraries that employ more abstract patterns, which in turn may make Rust harder to use. As [burntsushi wrote](https://github.com/rust-lang/rust/pull/96709#issuecomment-1168643277), "By increasing the accessibility to that power, that power will in turn be used more frequently and users of the language will need to contend with those abstractions. ... A lot of people have real difficulty understanding abstractions."
	> 
	> The lang team has to decide which direction to explore:
	> 
	> * **Deprecate GATs as an end-user feature.** Do not stabilize and instead explore alternatives. At this time there are not real alternatives under consideration, though vague ideas have been discussed.
	> * **Stabilize lifetime GATs only, deprecate type-based GATs.** This would accommodate many GAT users and allow patterns like [`Iterable`], but disallow the other patterns that abstract over types, helping to avoid the danger of "excess abstraction". 
	> * **Stabilize both type and lifetime GATs now.** We would commit to supporting GATs as an end-user primitive. This does not preclude us from adding future features that leverage GATs as a "desugaring target" as well, if they carry their weight.
	> 
	> The recommendation of the GATs initiative is to **stabilize the MVP and commit to having GATs as a primitive**, for the following reasons:
	> 
	> * GATs don't only make things more complex, they make them simpler, too. APIs with GATs are often [easier to understand](https://rust-lang.github.io/generic-associated-types-initiative/mvp/concern-too-complex.html#counterpoint-gats-often-allow-library-authors-to-hide-complexity), as GATs capture the pattern being used directly. This is particularly true when it comes to lifetimes, since the primary alternative to GATs tends to be APIs that involve higher-ranked trait bounds (instead of `T: Iterable`, you get `T: for<'a> CanIter<'a>`, [as you can see in rustc's graph api](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/trait.WithSuccessors.html)). But it's also true for patterns involving types, where the alternatives tend to be [macros or code generation](https://rust-lang.github.io/generic-associated-types-initiative/mvp/concern-too-complex.html#counterpoint-macros-are-not-easier).
	> * There is no "natural" reason to exclude types/lifetimes, it is an artificial limitation that doesn't arise from anything else. Moreover, most of the confusion that arises from GATs arises with lifetimes just as much as types, so we're not saving much. These sorts of artificial limits ultimately make the language more confusing, because things you would expect to work do not ("why can't I use a type here?").
	> * There are a wide variety of patterns that rely on type-dependent GATs to capture. As one particular example, [if we wish to provide traits for async libraries](https://github.com/rust-lang/rust/pull/96709#issuecomment-1173251079) -- e.g., to abstract over an executor that can spawn tasks -- they will almost certainly require type-based GATs -- e.g., to abstract over types like the `JoinHandle<T>` found in [tokio](https://docs.rs/tokio/latest/tokio/task/struct.JoinHandle.html) vs [async-std](https://docs.rs/async-std/latest/async_std/task/struct.JoinHandle.html). You can find other examples in the [design patterns](https://rust-lang.github.io/generic-associated-types-initiative/design_patterns.html) section.
	> 
	> You can read more details on these pages on the GAT website:
	> 
	> * [Concern: GATs permit abstractions that make Rust harder to use](https://rust-lang.github.io/generic-associated-types-initiative/mvp/concern-too-complex.html)
	> * [Concern: we should stabilize lifetime GATs only](https://rust-lang.github.io/generic-associated-types-initiative/mvp/concern-lifetimes-only.html)
	> 
	> #### Should we stabilize GATs now, or wait until we have improved the known shortcomings?
	> 
	> The current state of GATs include a number of known shortcomings, ranging from papercuts to severe limitations on expressiveness. Some of these are "by design". For example, we are [requiring users to add `where Self: 'a` bounds explicitly](https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html), which leaves room for us to make those either defaulted or optional in the future. We are also prohibiting GATs from being used in `dyn` types for now, and only stabilizing a rather verbose `for<'a>` syntax.
	> 
	> Other shortcomings are symptoms of deeper refactorings needed on the trait checker and are not truly *GAT* specific, but they arise more often when using GATs:
	> 
	> * Classification as early- vs late-bound involving type aliases is unrealiable (e.g., [#85533]), this is not a GATs issue but hits GATs when they are put behind an alias
	> * Associated type normalization, especially in closure signatures, doesn't always work (e.g., [#88382], [#88460])
	> * Lack of implied bounds in higher-ranked trait bounds and types can reject valid programs (e.g., [#87748], [#88526], [#91693])
	> * Polonius is required to borrow check patterns with GATs (e.g., [#92985])
	> 
	> [#85533]: https://github.com/rust-lang/rust/issues/85533
	> [#87748]: https://github.com/rust-lang/rust/issues/87748
	> [#92985]: https://github.com/rust-lang/rust/issues/92985
	> [#88382]: https://github.com/rust-lang/rust/issues/88382
	> [#88460]: https://github.com/rust-lang/rust/issues/88460
	> [#88526]: https://github.com/rust-lang/rust/issues/88526
	> [#91693]: https://github.com/rust-lang/rust/issues/91693
	> 
	> This latter class of limitations are hard to convey to users: things just kind of randomly don't work, and it's not obvious that this is the compiler's fault (this is kind of a "worst case" for learnability, since it can trick you into thinking you don't understand the model, when in fact you do). It may be possible to add diagnostics suggesting that GATs could be at fault, but it's hard to know until we try.
	> 
	> The recommendation of the GAT initiative is to stabilize now, despite the shortcomings, for the following reasons:
	> 
	> * There are [lots of people and projects successfully using GATs in their current state](https://rust-lang.github.io/generic-associated-types-initiative/design_patterns.html#list-of-projects-using-gats), and [not](https://github.com/rust-lang/rust/pull/96709#issuecomment-1131885602) [only](https://github.com/rust-lang/rust/pull/96709#issuecomment-1119760258) "type wizards". Despite the limitations, there are a lot of patterns that do work well.
	>     * On the other side, [this is a good comment](https://github.com/rust-lang/rust/pull/96709#issuecomment-1126690737) from someone who found the current state confusing, which also includes some points on possible variations on the syntax that could be considered, e.g., `type fn` instead of `type`. Thanks for the thoughtful feedback, @ZoopOTheGoop!
	> * [Lacking GATs is *itself* a usability hazard.](https://github.com/rust-lang/rust/pull/96709#issuecomment-1130190157) The workarounds for not having GATs are often really complex and also suffer from confusing error messages and poor usability.
	> * We now have the [types team] and it is functioning pretty well, which helps give confidence that we will be able to address these deeper issues (as well as land smaller improvements). For example, [a-mir-formality was recently extended to model a fix for the implied bounds problem](https://github.com/rust-lang/types-team/blob/master/minutes/2022-07-08-implied-bounds-and-wf-checking.md), though it's not clear yet how quickly we can land that work in rustc.
	> * In general, it's better to offer an incomplete solution than no solution at all. Consider async functions -- there's lots that remains to be done to make them more usable, but aren't we glad they exist on stable?
	> 
	> [types team]: https://github.com/rust-lang/types-team
	> 
	> You can read more details on these pages on the GAT website:
	> 
	> * [Concern: GATs are too hard to learn, especially in their current state](https://rust-lang.github.io/generic-associated-types-initiative/mvp/concern-too-rough.html)
	> 
	> ### Questions for T-types
	> 
	> #### Are we confident we can address the known shortcomings without backwards incompatible changes?
	> 
	> The stabilization report includes a number of known shortcomings, most of which are independent from GATs (but occur more frequently with GATs) -- e.g., interactions with early- vs late-bounds, shortcomings of normalization, etc. Do we feel confident that, if we stabilize now, we are going to be able to address those concerns without requiring changes to the user-facing syntax?
	> 
	> The recommendation of the GAT initiative is yes, we can, as most of the shortcomings are in fact orthogonal to GATs (e.g., polonius, implied bounds on HRTB, etc). See the Frequently Asked Questions below for a few more details.
	> 
	> #### Are we confident that we have the right rules for required bounds?
	> 
	> @QuineDot raised the point that the required bounds *as implemented* do not match the documentation. In particular, the implementation examines methods where a GAT appears in the return type to determine required bounds, but doesn't consider GATs that appear in argument position:
	> 
	> ```rust
	> trait LendingIterator {
	>     type Item<'a>;
	>     
	>     fn next(&mut self) -> Self::Item<'_>;
	>     //                               ^^
	>     //                               
	>     // Because of reference, we require `Self: 'a`
	>     // on the GAT above.
	> 
	>     fn push_back<'s>(&'s mut self, item: Self::Item<'s>);
	>     //                                  ^^^^^^^^^^^^^^
	>     //
	>     // But this method would not trigger any such 
	>     // requirement.
	> }
	> ```
	> 
	> Obviously, we need to bring the documentation and the implementation into agreement. @jackh726 plans to investigate whether to extend the impl to consider GATs appearing in inputs and where-clauses, or modify the spec.
	> 
	> Ignoring that detail, the question is whether we feel confident that the required bounds are covering a *large enough* set of relationships. The goal is to leave room for us to add relationships by default in the future (should we choose to go that way); we may also opt to convert the existing error into a lint, and make it optional to add these where-clauses.
	> 
	> The recommendation of the GAT initiative is that, yes, the [current rules](https://rust-lang.github.io/generic-associated-types-initiative/design-discussions/outlives-defaults.html#reference-rules) suffice (pending invesigation of the above point). They are fairly general and basically uncover any relationships that exist between items. Even if find cases that are overlooked, those cases are likely to be quite obscure and can be accommodated through an edition at worst.
	> 
	> ### Questions for the thread
	> 
	> #### Are there things that should be in this FCP but are not?
	> 
	> I've tried to capture all the major themes I saw in the thread, but there's a lot, and I could've missed something. Feel free to raise points you feel were overlooked and I'll consider whether to add them in. Similarly, if you see any points in the FAQ below that you feel could be made more accurate, let me know.
	> 
	> ### Frequently asked questions
	> 
	> These questions are meant to be statements of fact, or at least "informed opinion", not arguments for or against stabilizing GATs.
	> 
	> #### What points of confusion are we "locking in" by stabilizing now?
	> 
	> Put another way, we are locking in some bits of syntax now. What are the sources of confusion we have seen with those bits of syntax?
	> 
	> **The distinction between *ensures clauses* and *where clauses*.** Given a trait like this:
	> 
	> ```rust
	> trait WidgetFactory {
	>     type Item<T>: Display
	>     where
	>         T: Debug;
	> }
	> ```
	> 
	> The `Display` bound indicates the impl must prove that `Item` is `Display`, but the `T: Debug` bound must be satisfied at the point where the type `F::Item<X>` is written (i.e., we must show that `X: Debug` to reference the GAT). [This has led to some confusion in the past](https://github.com/rust-lang/rust/issues/87831), and to some extent this is inherent in the syntax.
	> 
	> **The role of `<'a>` in `Foo<Bar<'a> = ...>` bounds.** Consider this function `foo`:
	> 
	> ```rust
	> fn foo<'a, T>()
	> where
	>     T: Iterable<Item<'a> = &'a u32>
	> ```
	> 
	> The where clause on `foo` states that, when a `T` is iterated with the specific lifetime `'a`, it will yield `&'a u32` values. This is unlikely to be what the user wanted. They probably wanted `for<'a> T: Iterable<Item<'a> = &'a u32>` -- i.e., to give the "pattern" of types that result, and not the result for some specific lifetime.
	> 
	> When you consider a similar example, but using types, the current syntax seems less surprising:
	> 
	> ```rust
	> fn foo<T>()
	> where
	>     T: Database<RefCount<u32> = Rc<u32>>
	> ```
	> 
	> In general, Rust uses `Foo<T>` both for defining a parameter `T` and for referencing an existing type `T`, depending on context. This can lead to confusion in other places, as well. For example, many users are suprised that `impl MyStruct<T>` does not define a type parameter `T`, but rather references an existing type:
	> 
	> ```rust=
	> struct MyStruct<T> {
	>     //          ^ defines a type parameter T
	> }
	> impl MyStruct<T> {
	>     //        ^ references a type T
	> }
	> ```
	> 
	> #### What is the estimate of how quickly we can fix the various known shortcomings?
	> 
	> We can probably put up custom diagnostics relatively quickly.
	> 
	> Landing shorthands or improved syntax for things like `T: for<'a> Iterator<Item<'a> = &'a u32>` is easy to code, but we have to reach consensus on what to do.
	> 
	> Fixing the deeper problems like implied bounds, poloniues is harder.  We may have improved implied bounds by end of year, but landing polonius (for example) will take more than that. Hard to give meaningful estimates at this time.
	> 
	> #### Where are the biggest backwards compatibility risks?
	> 
	> Most of the choices that we are stabilizing now are "forced" by existing bits of Rust syntax and semantics, and seem like somthing we would want to support no matter what. For example, the fact that `'a` works in this example seems potentially surprising, but required for consistency with the language overall... 
	> 
	> ```rust
	> fn do_something<'a>(...)
	> where
	>     T: Iterable<Item<'a> = &'a u32>
	> ```
	> 
	> ...though we have considered a lint suggesting this clause be rewritten to `T::Item<'a> = &'a u32`, assuming we ever accept bounds of that form; see also [#20041].
	> 
	> Similarly, while we would like to accept other notations for higher-ranked trait-bounds, the following syntax seems "implied" by Rust's existing constructs:
	> 
	> ```rust
	> T: for<'a> Iterable<Item<'a> = &'a u32>
	> ```
	> 
	> In other words, even if we later add support for `T: Iterable<for<'a> Item<'a> = &'a u32>` or `T: Iterable<Item<'_> = &'a u32>`, 
	> 
	> [#20041]: https://github.com/rust-lang/rust/issues/20041
	> 
	> The major exception is the ["required bounds"](https://rust-lang.github.io/generic-associated-types-initiative/design-discussions/outlives-defaults.html) rules. As we explain on the GAT repo webpage, [the rules are fairly general](https://rust-lang.github.io/generic-associated-types-initiative/design-discussions/outlives-defaults.html#how-do-you-know-youve-gotten-the-exact-rules-for-required-bounds-correct-for-backcompat). If we *do* decide to have (some subset of) the required bounds be added as defaults (and not written explicitly), it's always possible we'll wish we had different rules, but any such cases seem likely to be fairly obscure. We can manage that through an edition, in the worst case, or possibly by close cooperation with existing crate authors.
	> 
	> #### What routes are we closing off by stabilizing now?
	> 
	> Obviously, we would be closing off a world in which we do not have GATs at all. We are not closing off future extensions that might make GATs less necessary, like further improvements to `-> impl Trait` notation or nikomatsakis's wacky proposal for [associated types that are nested within other trait items](https://github.com/rust-lang/rust/pull/96709#issuecomment-1167769172), though we are reducing the motivation for those approaches significantly by giving people a more general primitive.
	> 
	> Apart from that, we are closing off a world where the syntax `Iterable<Item<'a> = &'a u32>` has an implied forall binder (which is, admittedly, likely the most common thing people want in that place).
	> 


### "do not mark interior mutable shared refs as dereferenceable" rust#98017

- **Link:** https://github.com/rust-lang/rust/pull/98017
- [**Tracking Comment**](https://github.com/rust-lang/rust/pull/98017#issuecomment-1163625324): 
	> Team member @joshtriplett has proposed to merge this. The next step is review by the rest of the tagged team members:
	> 
	> * [ ] @cramertj
	> * [x] @joshtriplett
	> * [ ] @nikomatsakis
	> * [ ] @pnkfelix
	> * [x] @scottmcm
	> 
	> Concerns:
	> 
	> * clarify-what-happens-with-nested-unsafe-cell (https://github.com/rust-lang/rust/pull/98017#issuecomment-1177652921)
	> 
	> Once a majority of reviewers approve (and at most 2 approvals are outstanding), this will enter its final comment period. If you spot a major issue that hasn't been raised at any point in this process, please speak up!
	> 
	> See [this document](https://github.com/rust-lang/rfcbot-rs/blob/master/README.md) for info about what commands tagged team members can give me.
- [**Initiating Comment**](https://github.com/rust-lang/rust/pull/98017#issuecomment-1163625302): 
	> @rfcbot merge

nikomatsakis: I'm going to release my concern and mark as reviewed. My comment is more about how to improve docs for more clarity than the idea behind this.
    
## Active FCPs
### "Deprecate target_vendor " lang-team#102

**Link:** https://github.com/rust-lang/lang-team/issues/102

### "Positional Associated Types" lang-team#126

**Link:** https://github.com/rust-lang/lang-team/issues/126

### "Interoperability With C++ Destruction Order" lang-team#135

**Link:** https://github.com/rust-lang/lang-team/issues/135

### "allow construction of non-exhaustive structs when using functional update syntax" lang-team#143

**Link:** https://github.com/rust-lang/lang-team/issues/143

### "Add #[deprecated_safe] attribute to allow functions be be marked unsafe in a backwards compatible fashion" lang-team#147

**Link:** https://github.com/rust-lang/lang-team/issues/147

### "Async fns in traits" lang-team#150

**Link:** https://github.com/rust-lang/lang-team/issues/150

### "Initiative: `?` traits, `try` blocks, `yeet` exprs, oh my" lang-team#160

**Link:** https://github.com/rust-lang/lang-team/issues/160

### "Initiative: Ghost types and blocks" lang-team#161

**Link:** https://github.com/rust-lang/lang-team/issues/161

### "Keyword generics" lang-team#162

**Link:** https://github.com/rust-lang/lang-team/issues/162



## P-critical issues

None.


## Nominated RFCs, PRs and issues discussed this meeting

### "Tracking Issue for asm_sym" rust#93333

**Link:** https://github.com/rust-lang/rust/issues/93333

joshtriplett: Ready for stabilization FCP. Any concerns with starting an FCP?

### "Don't allow unwinding from Drop impls" rfcs#3288

**Link:** https://github.com/rust-lang/rfcs/pull/3288

joshtriplett: I expect this will be an interesting challenge. I don't think we're likely to get full community consensus on this one. We have a lot of enthusiasm but also a lot of objections; I don't know that there's a way to make a call so that everyone is satisfied.
    
nikomatsakis: I assume it's two concerns, this is kinda' useful, and backwards compatibility?
    
joshtriplett: The latter mostly. More that they want to use this and they want it to keep working forever.
    
joshtriplett: Tradeoff, we can get some benefits if you opt-in to using this, similar to panic=abort. But doing it by default, and potentially removing the ability to *not* abort on panic-in-drop in the future, is that it would eliminate the need for libraries to handle that case. Unsafe code could assume that dropping an object won't unwind, which substantially simplifies writing panic-safe or unwind-safe code. Argument is essentially "stdlib got it wrong, what chance do most crates have".
    
joshtriplett: On the other side, people are trying to build robust software that "should not stop". They want to be able to catch all panics at the request level and avoid bringing down the whole application. Makes perfect sense. They're concern is that this introduces a new path by which you abort the entire application, as opposed to only a single request.
    
joshtriplett: Personally, I feel there are other ways to abort (e.g., panic while panicking). Similarly, panicking while holding a lock will poison it, and if it survives requests that will cause problems. I don't think this makes the situation appreciably worse -- catching panics in a server will be best effort, in that there will be some aborts you can't catch -- but I appreciate the argument "hey, this worked before, and it doesn't work now, that seems like a breaking change". The tradeoff is "there's lots of stuff you may not know about that's broken because of this". It's not quite that we're closing a soundness hole, it's absolutely possible to work around this and write code that is completely safe, but basically nobody does. 
    
joshtriplett: By all means we should discuss, but I wanted to take the temperature of the rest of the team -- assuming we're in agreement on the change, are we willing to go forward even if we can't reach full consensus from the community? If not, we might as well close it down.
    
nikomatsakis: I never expect to reach full consensus from the community. Is it even possible? Looking at who happens to comment on an RFC doesn't tell us much, there could be people who've never even seen it.
    
scottmcm: Do we know if there are any possible impl strategies for .. this abort is a full abort, right? Is there any possibility for something like "thread abort", kind of a thing?
    
joshtriplett: If you did that, you'd still leave any data structures half-modified from that thread in an inconsistent thread, so that wouldn't solve the problem of unsafe code being hard to write.
    
scottmcm: Right, because `AssertUnwindSafe` is useless (I object! -ed.), and scoped threads still exist.
    
joshtriplett: There are some tweaks. One is that you could plausibly have a hook that runs before the abort, so that you can do something like "hey I'm dying". That seems valid. (Tangent with subsequent realization: Another would be drop could allow unwind when you're in drop and then, if it reaches the boundary of the drop glue, it aborts at that point. That may be what's being proposed here, and needs to be more explicitly captured. Oh, it does say that. Line 191. Never mind, it's just "we might want to have a hook".)
 
scottmcm: If we had a way to say -- something we could move towards -- where stack overflow wouldn't also kill your entire program -- then we could use that for this. But personally I'm ending up at "I don't know that I've seen that this is a particularly common place for this to happen" and there are other reasons your program can striaght-up die, even just with safe code, so that says to me that unwinding out of drop is the same sort of "technically it was possible but we don't care because it's about as likely as a stack overflow", that also is sort of a code bug.
    
scottmcm: Would we be willing to say "hey, this means we should add language level defer", as a way to run code -- ah, but that would have the same problems, we still need the deferred code to not panic?
    
joshtriplett: We can theoretically add some mechanism for careful handling. I've seen a variant of catch-unwind that places the object you catch inside of a "defused" object that won't run drop-glue -- like `ManuallyDrop` -- such that you can look at it but you're going to leak it unless you manually drop it.
    
nikomatsakis: by defer, scottmcm, did you mean go-style, inline destructors?
    
scottmcm: one place I remember for why you would WANT to panic. If you use scope-guard, you might want to panic out of that, given lack of defer.
    
nikomatsakis: ok. why would that have the same problem? I don't think it would.
    
nikomatsakis: Because I think the argument against drop panicking in unsafe code is that the drop calls are implicit and happening all over the place, e.g., each time I truncate a vector, but that doesn't apply to defer (of course defer would still abort if it panicked when panicking).
    
scottmcm: also, what is drop-in-place supposed to do when e.g. one element of a `[T]` panics?
    
nikomatsakis: way way back I remember we had some idea that it would go on and drop the other things and then rethrow, but yeah, it's hard, there's no right answer.
    
nikomatsakis: It sounds like josh you are saying that people are not citing examples of "this is code that intentionally makes use of a panic" but more like "you are making my panic recovery work less well", is that right?
    
joshtriplett: People have code where they do expect the possibility of panic in drop, but I don't know of any that is depending on it. Once example I've seen is an object that, when dropped, will restore the screen mode, and you want to make sure that, on exit of the program, you always restore the screen. Two separate things there: the actual calls to restore the screen could panic, but also, if something else in the panics in a drop impl, you would abort but not restore the screen. These are the kinds of cases. I don't think people have a specific case of "I am definitely going to hit this and I think it will be a serious problem". It's more that it feels like a reduction in robustness, and I think people are weighing that against the improvement to robustness that will result from this. It's possible someone has brought something and I missed it, but I've not seen it.

nikomatsakis: I feel like this conversation has been going on for a long time and I suspect we've heard all the arguments, so I think we need to decide whether to go forward. I'm comfortable with FCP'ing but not sure how to proceed procedurally.
    
simulacrum: I agree the arguments have been heard, but I think the RFC in its current form is not in a place where I'd be comfortable approving it. I think it makes arguments (e.g., we should do this because of performance), and I think that's not the strongest argument. When this lands on reddit etc we want the full arguments in the RFC. Once that is done there, yes, let's FCP.
    
nikomatsakis: Would you argue against FCP'ing, or just raising concerns?
    
simulacrum: I don't like FCP'ing when we have major edits pending.
    
nikomatsakis: Good point, then it's very unclaer what is being "FCP'd exactly".
    
joshtriplett: Capturing the arguments:
    
- we'd lke to see some kind of hook mechanism to allow you to run code
- like to see the correctness argument put in the forefront so that perception is not that we are doing this for perf + optimization reasons, the perf is a bonus

Anything else that needs adjustment?
    
simulacrum: I think the current discussion on the RFC doesn't address the alternatives very deeply, e.g., it doesn't really discuss the defer case. Adding that text -- more so for us in 10 years when someone comes back -- is worthwhile.
    
joshtriplett: Can you clarify what you mean by the defer case? 
    
simulacrum: If we go back to the example we had in this meeting, that defer could panic without disturbing unsafe code -- there are similar cases, e.g., with a generic T in unsafe code, it's really easy to miss the drop, but with a known T, or a known defer, it's plausible you are intentionally panicking during drop, so I think that avenue of discussion, maybe it's a future possibility, maybe something else, it isn't really thoroughly explored.

joshtriplett: Can you add that in a follow-up comment on the issue? I don't think I will do it justice.
    
simulacrum: It's been raised on the thread.
    
joshtriplett: A lot of things have, but many of them get lost.
    
simulacrum: I can do that if it doesn't self-happen.
    
nikomatsakis: I get what Mark is saying. This is revisiting a design and we need the coverage to be exhaustive. I think we should add a Frequently Asked Questions, which I think is a useful heading for this kind of thing.

joshtriplett: I wrote a [summary comment](https://github.com/rust-lang/rfcs/pull/3288/#issuecomment-1182096605) and tried to capture the tradeoffs where, in both cases we are aiming for robustness. If you feel I missed something, let me know.
    
### meaning of "unused" in lints
    
Just something on IRLO I wanted to raise: [Should dead code count toward var liveness?](https://internals.rust-lang.org/t/should-dead-code-count-toward-var-liveness/16996).

(Can probably be async, but I know some don't follow IRLO too closely.)

nikomatsakis: that's an interesting example. Not totally clear what it should do.
    
### "Implement pointee metadata unsizing via a TypedMetadata<T\> container" rust#97052

**Link:** https://github.com/rust-lang/rust/pull/97052

nikomatsakis: There were some responses, but I haven't had time to read them closely. We should read them at some point. It seems like maybe this is motivated by the `Storage` API?
    
joshtriplett: I don't really feel like the comment helped my understanding of why we want this to be a coercion? I see a lot of code mostly.
    
nikomatsakis: Maybe ask them to clarify?
    
### "Tracking Issue for `#[instruction_set]` attribute (RFC 2867)" rust#74727

**Link:** https://github.com/rust-lang/rust/issues/74727
    
joshtriplett: Lokathor feels this is ready. We're blocked on pnkfelix to start the FCP.

### "`-C inline-threshold` has no effect with new LLVM pass manager" rust#89742

**Link:** https://github.com/rust-lang/rust/issues/89742

joshtriplett: Is this lang? I think we might be concerned if `#[inline(always)]` never inlined, but in general we are not especially concerned. Any kind of hint like this on the command line is not considered lang.
    
nikomatsakis: Even `#[inline(always)]` doesn't make guarantees -- 
    
joshtriplett: I realize that, but I consider that a bug ---
    
nikomatsakis: To me, it's more that `#[inline(always)]` is really just a rather strong hint. But that's ok.
    
### "`$$crate` unexpectedly fails to defer which crate `$crate` refers to" rust#99035

**Link:** https://github.com/rust-lang/rust/issues/99035

simulacrum: This is potentially release critical. The question that's important for this meeting is whether we want to back out the stabilization of `$$` because of this interaction until we make a decision. I haven't read the actual text, it's just that it's newly stabilized so we have a limited time window to make a decision.
    
joshtriplett: My initial reaction is that the current behavior is not correct. But I'm not... sure about that. 
    
nikomatsakis: Seems like we should back it out. Fix it. Make sure it's working how we like and then stabilize it.
    
joshtriplett: Reading the rest of the comments, it sounds like another reason to want to write this is to write macros that make it easier to generate macros, and you may want to use those macros... no actually, the way it's describing here it sounds to me to be correct to want `$crate` to be the crate that does the expansion?
    
nikomatsakis: Mark, can you write out a comment to suggest a revert?
    
simulacrum: I can leave a comment, I don't have bandwidth to do the revert itself, but I'll ask whether someone else can and nominate for compiler if not.
    
### "Strengthen invalid_value lint to forbid uninit primitives, adjust docs to say that's UB" rust#98919

**Link:** https://github.com/rust-lang/rust/pull/98919

joshtriplett: So this sounds like it might be straightforward. (famous last words. -ed.) The ask from Ralf is confirming that... hmm. The ask is to confirm that putting uninit memory into an arbitrary value is undefined behavior. I think the *ask* is fairly simple, but the answer is hard.
    
Leaving further discussion for next time.

### "Tracking issue for function attribute `#[no_coverage]`" rust#84605

**Link:** https://github.com/rust-lang/rust/issues/84605

nikomatsakis: tmandry commented that this is ready to be stabilized and was asking more of a procedural question.
    
simulacrum: 7 days ago we commented and said do the report and let's do it.

https://github.com/rust-lang/rust/issues/84605#issuecomment-1175321094
    
## Nominated RFCs, PRs and issues NOT discussed this meeting

